<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš¨ PixelCanvas Debug - 65,536ãƒ”ã‚¯ã‚»ãƒ«è¡¨ç¤ºå•é¡Œè¨ºæ–­</title>
    <style>
        body { font-family: monospace; background: #1a1a1a; color: #00ff00; margin: 20px; }
        .debug-panel { background: #000; border: 1px solid #00ff00; padding: 15px; margin: 10px 0; }
        .error { color: #ff4444; }
        .success { color: #44ff44; }
        .warning { color: #ffaa00; }
        button { background: #333; color: #00ff00; border: 1px solid #00ff00; padding: 10px; margin: 5px; cursor: pointer; }
        button:hover { background: #00ff00; color: #000; }
        #canvas { border: 2px solid #00ff00; }
        .info { color: #aabbff; }
    </style>
</head>
<body>
    <h1>ğŸš¨ PixelCanvas Debug Tool - 65,536ãƒ”ã‚¯ã‚»ãƒ«å•é¡Œè¨ºæ–­</h1>
    
    <div class="debug-panel">
        <h3>ğŸ“Š ç¾åœ¨ã®çŠ¶æ³</h3>
        <div id="status">åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <div class="debug-panel">
        <h3>ğŸ”§ ãƒ‡ãƒãƒƒã‚°æ“ä½œ</h3>
        <button onclick="checkPixelStorage()">PixelStorageç¢ºèª</button>
        <button onclick="checkViewport()">ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆç¢ºèª</button>
        <button onclick="forceRenderAll()">å…¨ãƒ”ã‚¯ã‚»ãƒ«å¼·åˆ¶æç”»</button>
        <button onclick="testDirectRender()">ç›´æ¥æç”»ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="analyzeSupabaseData()">Supabaseãƒ‡ãƒ¼ã‚¿è§£æ</button>
        <button onclick="debugCoordinateTransform()">åº§æ¨™å¤‰æ›ãƒ‡ãƒãƒƒã‚°</button>
    </div>
    
    <div class="debug-panel">
        <h3>ğŸ¯ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ</h3>
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>
    
    <div class="debug-panel">
        <h3>ğŸ“‹ è¨ºæ–­çµæœ</h3>
        <div id="results"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // PixelCanvasè¨­å®šï¼ˆç°¡æ˜“ç‰ˆï¼‰
        const CONFIG = {
            GRID_SIZE: 256,
            PIXEL_SIZE: 4,
            SUPABASE_URL: 'https://lgvjdefkyeuvquzckkvb.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY',
            COLORS: ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#800000', '#008000', '#000080', '#808000', '#800080', '#008080', '#C0C0C0', '#808080']
        };
        
        let supabaseClient = null;
        let pixelData = new Map();
        let canvas = null;
        let ctx = null;
        
        // åˆæœŸåŒ–
        window.addEventListener('load', async () => {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            try {
                supabaseClient = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
                log('âœ… Supabase client created', 'success');
                await initialDiagnosis();
            } catch (error) {
                log('âŒ Supabase initialization failed: ' + error.message, 'error');
            }
        });
        
        function log(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            const className = type;
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `<div class="${className}">[${timestamp}] ${message}</div>`;
            resultsDiv.innerHTML = logEntry + resultsDiv.innerHTML;
            
            if (type === 'error') {
                statusDiv.innerHTML = `<span class="error">${message}</span>`;
            } else if (type === 'success') {
                statusDiv.innerHTML = `<span class="success">${message}</span>`;
            } else {
                statusDiv.innerHTML = `<span class="info">${message}</span>`;
            }
        }
        
        async function initialDiagnosis() {
            log('ğŸ” åˆæœŸè¨ºæ–­é–‹å§‹...', 'info');
            
            // 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šç¢ºèª
            try {
                const { count, error } = await supabaseClient
                    .from('pixels')
                    .select('*', { count: 'exact', head: true });
                    
                if (error) throw error;
                log(`ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šOK - ç·ãƒ”ã‚¯ã‚»ãƒ«æ•°: ${count}`, 'success');
            } catch (error) {
                log(`âŒ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                return;
            }
            
            // 2. ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ã®ãƒ”ã‚¯ã‚»ãƒ«æ•°ç¢ºèª
            try {
                const { count, error } = await supabaseClient
                    .from('pixels')
                    .select('*', { count: 'exact', head: true })
                    .eq('sector_x', 0)
                    .eq('sector_y', 0);
                    
                if (error) throw error;
                log(`ğŸ¯ ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ãƒ”ã‚¯ã‚»ãƒ«æ•°: ${count}`, count > 0 ? 'success' : 'warning');
                
                if (count === 65536) {
                    log('âœ… å®Œå…¨ã«åŸ‹ã¾ã£ã¦ã„ã‚‹ï¼ˆ65,536ãƒ”ã‚¯ã‚»ãƒ«ï¼‰', 'success');
                } else if (count > 0) {
                    log(`âš ï¸ éƒ¨åˆ†çš„ã«åŸ‹ã¾ã£ã¦ã„ã‚‹ï¼ˆ${count}/65,536ãƒ”ã‚¯ã‚»ãƒ«ï¼‰`, 'warning');
                } else {
                    log('âŒ ç©ºã®ã‚»ã‚¯ã‚¿ãƒ¼', 'error');
                }
            } catch (error) {
                log(`âŒ ã‚»ã‚¯ã‚¿ãƒ¼ç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
            
            // 3. ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            await loadPixelsFromSupabase();
        }
        
        async function loadPixelsFromSupabase() {
            log('ğŸ“¥ Supabaseã‹ã‚‰ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
            
            try {
                // ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ã®å…¨ãƒ”ã‚¯ã‚»ãƒ«ã‚’èª­ã¿è¾¼ã¿
                const { data: pixels, error } = await supabaseClient
                    .from('pixels')
                    .select('sector_x, sector_y, local_x, local_y, color')
                    .eq('sector_x', 0)
                    .eq('sector_y', 0)
                    .limit(70000);
                    
                if (error) throw error;
                
                log(`ğŸ“¦ èª­ã¿è¾¼ã¿å®Œäº†: ${pixels.length}ãƒ”ã‚¯ã‚»ãƒ«`, 'success');
                
                // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’Mapã«ä¿å­˜
                pixelData.clear();
                for (const pixel of pixels) {
                    const key = `${pixel.sector_x},${pixel.sector_y},${pixel.local_x},${pixel.local_y}`;
                    pixelData.set(key, pixel.color);
                }
                
                log(`ğŸ’¾ ãƒ¡ãƒ¢ãƒªä¿å­˜å®Œäº†: ${pixelData.size}ãƒ”ã‚¯ã‚»ãƒ«`, 'success');
                
                // ã‚µãƒ³ãƒ—ãƒ«ãƒ”ã‚¯ã‚»ãƒ«ç¢ºèª
                const sampleKeys = Array.from(pixelData.keys()).slice(0, 5);
                log(`ğŸ” ã‚µãƒ³ãƒ—ãƒ«ãƒ”ã‚¯ã‚»ãƒ«: ${sampleKeys.join(', ')}`, 'info');
                
            } catch (error) {
                log(`âŒ ãƒ”ã‚¯ã‚»ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function checkPixelStorage() {
            log('ğŸ” PixelStorageçŠ¶æ³ç¢ºèª...', 'info');
            log(`ğŸ“Š ç¾åœ¨ã®ãƒ”ã‚¯ã‚»ãƒ«æ•°: ${pixelData.size}`, 'info');
            
            if (pixelData.size === 0) {
                log('âŒ ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™', 'error');
                return;
            }
            
            // åˆ†å¸ƒç¢ºèª
            const sectorCount = new Map();
            for (const key of pixelData.keys()) {
                const [sectorX, sectorY] = key.split(',').map(Number);
                const sectorKey = `${sectorX},${sectorY}`;
                sectorCount.set(sectorKey, (sectorCount.get(sectorKey) || 0) + 1);
            }
            
            log('ğŸ“ ã‚»ã‚¯ã‚¿ãƒ¼åˆ¥åˆ†å¸ƒ:', 'info');
            for (const [sector, count] of sectorCount) {
                log(`  ã‚»ã‚¯ã‚¿ãƒ¼${sector}: ${count}ãƒ”ã‚¯ã‚»ãƒ«`, 'info');
            }
        }
        
        async function checkViewport() {
            log('ğŸ” ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆç¢ºèª...', 'info');
            
            const canvasRect = canvas.getBoundingClientRect();
            log(`ğŸ“ Canvas ã‚µã‚¤ã‚º: ${canvasRect.width}x${canvasRect.height}`, 'info');
            
            // ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ã®è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—
            const scale = 1.0; // ä»®ã®ã‚¹ã‚±ãƒ¼ãƒ«
            const offsetX = 0; // ä»®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            const offsetY = 0;
            
            const sectorSize = CONFIG.GRID_SIZE * CONFIG.PIXEL_SIZE * scale; // 256 * 4 * 1 = 1024
            log(`ğŸ“ ã‚»ã‚¯ã‚¿ãƒ¼ã‚µã‚¤ã‚º: ${sectorSize}px (scale: ${scale})`, 'info');
            
            const sectorScreenX = offsetX;
            const sectorScreenY = offsetY;
            log(`ğŸ“ ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ç”»é¢ä½ç½®: (${sectorScreenX}, ${sectorScreenY})`, 'info');
            
            if (sectorScreenX > canvasRect.width || sectorScreenY > canvasRect.height || 
                sectorScreenX + sectorSize < 0 || sectorScreenY + sectorSize < 0) {
                log('âŒ ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ãŒç”»é¢å¤–ã«ã‚ã‚Šã¾ã™ï¼', 'error');
            } else {
                log('âœ… ã‚»ã‚¯ã‚¿ãƒ¼(0,0)ã¯ç”»é¢å†…ã«ã‚ã‚Šã¾ã™', 'success');
            }
        }
        
        async function forceRenderAll() {
            log('ğŸ¨ å…¨ãƒ”ã‚¯ã‚»ãƒ«å¼·åˆ¶æç”»ãƒ†ã‚¹ãƒˆ...', 'info');
            
            if (pixelData.size === 0) {
                log('âŒ ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™', 'error');
                return;
            }
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#404040';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const scale = 0.5; // å°ã•ã‚ã®ã‚¹ã‚±ãƒ¼ãƒ«ã§å…¨ä½“ã‚’è¡¨ç¤º
            const offsetX = 50;
            const offsetY = 50;
            
            let rendered = 0;
            const maxRender = 5000; // è¡¨ç¤ºåˆ¶é™
            
            for (const [key, colorIndex] of pixelData) {
                if (rendered >= maxRender) break;
                
                const [sectorX, sectorY, localX, localY] = key.split(',').map(Number);
                
                // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›
                const worldX = sectorX * CONFIG.GRID_SIZE + localX;
                const worldY = sectorY * CONFIG.GRID_SIZE + localY;
                
                // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã«å¤‰æ›
                const screenX = worldX * CONFIG.PIXEL_SIZE * scale + offsetX;
                const screenY = worldY * CONFIG.PIXEL_SIZE * scale + offsetY;
                const pixelSize = CONFIG.PIXEL_SIZE * scale;
                
                // ç”»é¢å†…ãƒã‚§ãƒƒã‚¯
                if (screenX >= 0 && screenY >= 0 && 
                    screenX < canvas.width && screenY < canvas.height) {
                    
                    const color = CONFIG.COLORS[colorIndex] || '#FFFFFF';
                    ctx.fillStyle = color;
                    ctx.fillRect(screenX, screenY, Math.max(1, pixelSize), Math.max(1, pixelSize));
                    rendered++;
                }
            }
            
            log(`ğŸ¨ æç”»å®Œäº†: ${rendered}/${pixelData.size}ãƒ”ã‚¯ã‚»ãƒ« (scale: ${scale})`, 'success');
            
            if (rendered === 0) {
                log('âŒ 1ã¤ã‚‚ãƒ”ã‚¯ã‚»ãƒ«ãŒæç”»ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸï¼', 'error');
            } else if (rendered < 1000) {
                log('âš ï¸ æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°ãŒå°‘ãªã„ã§ã™', 'warning');
            }
        }
        
        async function testDirectRender() {
            log('ğŸ”§ ç›´æ¥æç”»ãƒ†ã‚¹ãƒˆé–‹å§‹...', 'info');
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#404040';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ‰‹å‹•ã§æ•°ãƒ”ã‚¯ã‚»ãƒ«æç”»
            const testPixels = [
                { x: 0, y: 0, color: 1 },
                { x: 1, y: 0, color: 2 },
                { x: 0, y: 1, color: 3 },
                { x: 1, y: 1, color: 4 },
                { x: 100, y: 100, color: 5 }
            ];
            
            const scale = 2;
            const offsetX = 100;
            const offsetY = 100;
            
            for (const pixel of testPixels) {
                const screenX = pixel.x * CONFIG.PIXEL_SIZE * scale + offsetX;
                const screenY = pixel.y * CONFIG.PIXEL_SIZE * scale + offsetY;
                const pixelSize = CONFIG.PIXEL_SIZE * scale;
                
                ctx.fillStyle = CONFIG.COLORS[pixel.color];
                ctx.fillRect(screenX, screenY, pixelSize, pixelSize);
            }
            
            log(`âœ… ç›´æ¥æç”»ãƒ†ã‚¹ãƒˆå®Œäº†: ${testPixels.length}ãƒ”ã‚¯ã‚»ãƒ«`, 'success');
        }
        
        async function analyzeSupabaseData() {
            log('ğŸ” Supabaseãƒ‡ãƒ¼ã‚¿è©³ç´°è§£æ...', 'info');
            
            try {
                // å®Ÿéš›ã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚µãƒ³ãƒ—ãƒ«ã‚’å–å¾—
                const { data: sample, error } = await supabaseClient
                    .from('pixels')
                    .select('*')
                    .eq('sector_x', 0)
                    .eq('sector_y', 0)
                    .limit(10);
                    
                if (error) throw error;
                
                log('ğŸ“‹ ã‚µãƒ³ãƒ—ãƒ«ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿:', 'info');
                for (const pixel of sample) {
                    log(`  (${pixel.sector_x},${pixel.sector_y},${pixel.local_x},${pixel.local_y}) = è‰²${pixel.color}`, 'info');
                }
                
                // è‰²åˆ†å¸ƒç¢ºèª
                const colorCount = new Map();
                for (const pixel of sample) {
                    colorCount.set(pixel.color, (colorCount.get(pixel.color) || 0) + 1);
                }
                
                log('ğŸ¨ è‰²åˆ†å¸ƒ (ã‚µãƒ³ãƒ—ãƒ«):', 'info');
                for (const [color, count] of colorCount) {
                    log(`  è‰²${color} (${CONFIG.COLORS[color]}): ${count}å€‹`, 'info');
                }
                
            } catch (error) {
                log(`âŒ ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function debugCoordinateTransform() {
            log('ğŸ§® åº§æ¨™å¤‰æ›ãƒ‡ãƒãƒƒã‚°...', 'info');
            
            const testCases = [
                { sector: [0, 0], local: [0, 0] },
                { sector: [0, 0], local: [255, 255] },
                { sector: [0, 0], local: [100, 100] },
                { sector: [1, 0], local: [0, 0] },
                { sector: [0, 1], local: [0, 0] }
            ];
            
            const scale = 1;
            const offsetX = 0;
            const offsetY = 0;
            
            log('ğŸ“ åº§æ¨™å¤‰æ›ãƒ†ã‚¹ãƒˆ:', 'info');
            for (const test of testCases) {
                const [sectorX, sectorY] = test.sector;
                const [localX, localY] = test.local;
                
                // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™
                const worldX = sectorX * CONFIG.GRID_SIZE + localX;
                const worldY = sectorY * CONFIG.GRID_SIZE + localY;
                
                // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™
                const screenX = worldX * CONFIG.PIXEL_SIZE * scale + offsetX;
                const screenY = worldY * CONFIG.PIXEL_SIZE * scale + offsetY;
                
                log(`  ã‚»ã‚¯ã‚¿ãƒ¼(${sectorX},${sectorY}) ãƒ­ãƒ¼ã‚«ãƒ«(${localX},${localY}) â†’ ãƒ¯ãƒ¼ãƒ«ãƒ‰(${worldX},${worldY}) â†’ ã‚¹ã‚¯ãƒªãƒ¼ãƒ³(${screenX},${screenY})`, 'info');
            }
        }
    </script>
</body>
</html>