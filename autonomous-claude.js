#!/usr/bin/env node

/**
 * Autonomous Claude Improvement System
 * Fully self-contained continuous improvement for PixelCanvas
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

class AutonomousSystem {
    constructor() {
        this.projectRoot = '/data/data/com.termux/files/home/pixcel_canvas';
        this.cycleCount = 0;
        this.isRunning = false;
        
        console.log('ðŸ¤– Autonomous Claude System initialized');
    }

    async startLoop() {
        this.isRunning = true;
        console.log('ðŸš€ Starting autonomous improvement loop');
        
        while (this.isRunning) {
            try {
                await this.executeCycle();
                console.log('â° Waiting 5 minutes for next cycle...');
                await this.sleep(300000); // 5 minutes
            } catch (error) {
                console.error('âŒ Cycle error:', error.message);
                await this.sleep(60000); // 1 minute on error
            }
        }
    }

    async executeCycle() {
        this.cycleCount++;
        console.log(`ðŸ”„ Cycle #${this.cycleCount} starting`);

        const issues = await this.detectIssues();
        if (issues.length === 0) {
            console.log('âœ… No issues detected');
            return;
        }

        const results = await this.implementFixes(issues);
        await this.commitChanges(results);
        
        console.log(`âœ… Cycle #${this.cycleCount} completed`);
    }

    async detectIssues() {
        console.log('ðŸ” Detecting issues...');
        const issues = [];

        try {
            // Check Config.js for performance settings
            const configPath = path.join(this.projectRoot, 'public', 'Config.js');
            const configContent = await fs.readFile(configPath, 'utf8');
            
            // Check VIEWPORT_UPDATE_THROTTLE
            const throttleMatch = configContent.match(/VIEWPORT_UPDATE_THROTTLE:\s*(\d+)/);
            if (throttleMatch && parseInt(throttleMatch[1]) > 50) {
                issues.push({
                    type: 'performance',
                    file: 'Config.js',
                    setting: 'VIEWPORT_UPDATE_THROTTLE',
                    current: parseInt(throttleMatch[1]),
                    target: 50
                });
            }

            // Check PIXI_MAX_TEXTURES
            const texturesMatch = configContent.match(/PIXI_MAX_TEXTURES:\s*(\d+)/);
            if (texturesMatch && parseInt(texturesMatch[1]) < 1000) {
                issues.push({
                    type: 'performance',
                    file: 'Config.js',
                    setting: 'PIXI_MAX_TEXTURES',
                    current: parseInt(texturesMatch[1]),
                    target: 1000
                });
            }

        } catch (error) {
            console.error('Detection error:', error.message);
        }

        console.log(`ðŸ” Found ${issues.length} issues`);
        return issues;
    }

    async implementFixes(issues) {
        console.log('ðŸš€ Implementing fixes...');
        const results = [];

        for (const issue of issues) {
            try {
                if (issue.type === 'performance' && issue.file === 'Config.js') {
                    const success = await this.updateConfigSetting(issue);
                    results.push({ issue, success });
                    
                    if (success) {
                        console.log(`âœ… Fixed: ${issue.setting} ${issue.current} â†’ ${issue.target}`);
                    }
                }
            } catch (error) {
                console.error(`âŒ Fix failed for ${issue.setting}:`, error.message);
                results.push({ issue, success: false });
            }
        }

        return results;
    }

    async updateConfigSetting(issue) {
        try {
            const configPath = path.join(this.projectRoot, 'public', 'Config.js');
            let content = await fs.readFile(configPath, 'utf8');
            
            const regex = new RegExp(`${issue.setting}:\\s*\\d+`);
            content = content.replace(regex, `${issue.setting}: ${issue.target}`);
            
            await fs.writeFile(configPath, content);
            return true;
        } catch {
            return false;
        }
    }

    async commitChanges(results) {
        const successfulFixes = results.filter(r => r.success);
        
        if (successfulFixes.length === 0) {
            console.log('â„¹ï¸ No changes to commit');
            return;
        }

        try {
            console.log('ðŸ’¾ Committing changes...');
            
            execSync('git add .', { cwd: this.projectRoot });
            
            const message = `ðŸ¤– Autonomous Improvement #${this.cycleCount}

${successfulFixes.map(f => `â€¢ ${f.issue.setting}: ${f.issue.current} â†’ ${f.issue.target}`).join('\n')}

ðŸ¤– Auto-generated by Claude Autonomous System`;

            execSync(`git commit -m "${message}"`, { cwd: this.projectRoot });
            execSync('git push origin main', { cwd: this.projectRoot });
            
            console.log('âœ… Changes committed and pushed');
            
        } catch (error) {
            console.error('âŒ Git operation failed:', error.message);
        }
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    stop() {
        this.isRunning = false;
        console.log('ðŸ›‘ System stopped');
    }
}

// Main execution
if (require.main === module) {
    const system = new AutonomousSystem();
    
    // Process signal handling
    if (typeof process !== 'undefined') {
        process.on('SIGINT', () => {
            console.log('ðŸ“´ Stopping...');
            system.stop();
            process.exit(0);
        });
    }

    system.startLoop().catch(error => {
        console.error('ðŸ’¥ System crashed:', error);
        if (typeof process !== 'undefined') {
            process.exit(1);
        }
    });
}

module.exports = AutonomousSystem;