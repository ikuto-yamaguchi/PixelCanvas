<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Freeze Issue Test</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: monospace; padding: 20px; }
        .test { margin: 10px 0; padding: 10px; border: 1px solid #333; }
        .pass { border-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .fail { border-color: #f44336; background: rgba(244, 67, 54, 0.1); }
        .running { border-color: #2196F3; background: rgba(33, 150, 243, 0.1); }
        button { padding: 10px; margin: 5px; background: #333; color: white; border: 1px solid #666; cursor: pointer; }
        .log { max-height: 300px; overflow-y: auto; background: #222; padding: 10px; margin: 10px 0; border: 1px solid #444; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üîç Freeze Issue Diagnostic Test</h1>
    
    <div class="test" id="test1">
        <h3>Test 1: Pixel Loading Performance</h3>
        <div id="test1-result">Testing...</div>
    </div>
    
    <div class="test" id="test2">
        <h3>Test 2: Rendering Performance</h3>
        <div id="test2-result">Testing...</div>
    </div>
    
    <div class="test" id="test3">
        <h3>Test 3: Event Handler Responsiveness</h3>
        <div id="test3-result">Testing...</div>
    </div>
    
    <div class="test" id="test4">
        <h3>Test 4: Memory Usage</h3>
        <div id="test4-result">Testing...</div>
    </div>
    
    <div>
        <button onclick="testSmallPixelSet()">Test Small Pixel Set (100)</button>
        <button onclick="testMediumPixelSet()">Test Medium Pixel Set (1000)</button>
        <button onclick="testLargePixelSet()">Test Large Pixel Set (10000)</button>
        <button onclick="testMovement()">Test Movement</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>
    
    <div class="log" id="testLog">Test log will appear here...</div>
    
    <script>
        const CONFIG = {
            SUPABASE_URL: 'https://lgvjdefkyeuvquzckkvb.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY',
            PIXEL_SIZE: 4,
            GRID_SIZE: 256,
            COLORS: [
                '#000000', '#FFFFFF', '#FF0000', '#00FF00',
                '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                '#800000', '#008000', '#000080', '#808000',
                '#800080', '#008080', '#C0C0C0', '#808080'
            ]
        };
        
        function log(message) {
            const testLog = document.getElementById('testLog');
            const timestamp = new Date().toLocaleTimeString();
            testLog.innerHTML += `[${timestamp}] ${message}<br>`;
            testLog.scrollTop = testLog.scrollHeight;
        }
        
        function setTestStatus(testId, status, message) {
            const test = document.getElementById(testId);
            const result = document.getElementById(testId + '-result');
            test.className = 'test ' + status;
            result.innerHTML = message;
        }
        
        async function runDiagnosticTests() {
            log('üîç Starting freeze diagnostic tests...');
            
            // Test 1: Pixel Loading Performance
            setTestStatus('test1', 'running', '‚è≥ Testing pixel loading performance...');
            try {
                const startTime = performance.now();
                
                // Test progressive loading
                const sizes = [100, 500, 1000, 5000, 10000];
                const results = [];
                
                for (const size of sizes) {
                    const testStart = performance.now();
                    const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=sector_x,sector_y,local_x,local_y,color&limit=${size}`, {
                        headers: {
                            'apikey': CONFIG.SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (response.ok) {
                        const pixels = await response.json();
                        const loadTime = performance.now() - testStart;
                        results.push({ size, loadTime: loadTime.toFixed(0), pixels: pixels.length });
                        log(`Loaded ${pixels.length} pixels in ${loadTime.toFixed(0)}ms`);
                        
                        // Check for freeze after each load
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                const totalTime = performance.now() - startTime;
                setTestStatus('test1', 'pass', `‚úÖ PASS: Loaded progressive sets<br>${results.map(r => `${r.pixels} pixels: ${r.loadTime}ms`).join('<br>')}<br>Total time: ${totalTime.toFixed(0)}ms`);
                
            } catch (error) {
                setTestStatus('test1', 'fail', `‚ùå FAIL: ${error.message}`);
                log(`Error in pixel loading test: ${error.message}`);
            }
            
            // Test 2: Rendering Performance
            setTestStatus('test2', 'running', '‚è≥ Testing rendering performance...');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');
                
                // Test rendering different pixel counts
                const renderTests = [100, 500, 1000, 2000, 5000];
                const renderResults = [];
                
                for (const count of renderTests) {
                    const startTime = performance.now();
                    
                    // Clear canvas
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Render test pixels
                    for (let i = 0; i < count; i++) {
                        const x = (i % 40) * 10;
                        const y = Math.floor(i / 40) * 10;
                        ctx.fillStyle = CONFIG.COLORS[i % 16];
                        ctx.fillRect(x, y, 4, 4);
                    }
                    
                    const renderTime = performance.now() - startTime;
                    renderResults.push({ count, renderTime: renderTime.toFixed(1) });
                    log(`Rendered ${count} pixels in ${renderTime.toFixed(1)}ms`);
                    
                    // Yield control to check for freezing
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
                
                setTestStatus('test2', 'pass', `‚úÖ PASS: Render performance OK<br>${renderResults.map(r => `${r.count} pixels: ${r.renderTime}ms`).join('<br>')}`);
                
            } catch (error) {
                setTestStatus('test2', 'fail', `‚ùå FAIL: ${error.message}`);
                log(`Error in rendering test: ${error.message}`);
            }
            
            // Test 3: Event Handler Responsiveness
            setTestStatus('test3', 'running', '‚è≥ Testing event responsiveness...');
            try {
                let eventCount = 0;
                const eventTimes = [];
                
                // Create test element
                const testDiv = document.createElement('div');
                testDiv.style.width = '100px';
                testDiv.style.height = '100px';
                testDiv.style.background = '#444';
                testDiv.style.margin = '10px 0';
                document.body.appendChild(testDiv);
                
                // Test event responsiveness
                const testEvents = () => {
                    return new Promise(resolve => {
                        const startTime = performance.now();
                        
                        testDiv.addEventListener('click', function handler() {
                            const responseTime = performance.now() - startTime;
                            eventTimes.push(responseTime);
                            eventCount++;
                            testDiv.removeEventListener('click', handler);
                            resolve();
                        });
                        
                        // Simulate click
                        testDiv.click();
                    });
                };
                
                // Test multiple events
                for (let i = 0; i < 5; i++) {
                    await testEvents();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                document.body.removeChild(testDiv);
                
                const avgResponseTime = eventTimes.reduce((a, b) => a + b, 0) / eventTimes.length;
                
                if (avgResponseTime < 50) {
                    setTestStatus('test3', 'pass', `‚úÖ PASS: Events responsive<br>Avg response: ${avgResponseTime.toFixed(1)}ms<br>Events handled: ${eventCount}`);
                } else {
                    setTestStatus('test3', 'fail', `‚ùå FAIL: Slow event response<br>Avg response: ${avgResponseTime.toFixed(1)}ms`);
                }
                
            } catch (error) {
                setTestStatus('test3', 'fail', `‚ùå FAIL: ${error.message}`);
                log(`Error in event test: ${error.message}`);
            }
            
            // Test 4: Memory Usage
            setTestStatus('test4', 'running', '‚è≥ Testing memory usage...');
            try {
                const memoryInfo = performance.memory ? {
                    used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                    total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                    limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                } : { message: 'Memory API not available' };
                
                setTestStatus('test4', 'pass', `‚úÖ Memory info:<br>${JSON.stringify(memoryInfo, null, 2).replace(/\\n/g, '<br>').replace(/ /g, '&nbsp;')}`);
                
            } catch (error) {
                setTestStatus('test4', 'fail', `‚ùå FAIL: ${error.message}`);
            }
            
            log('‚úÖ Diagnostic tests completed');
        }
        
        // Manual test functions
        window.testSmallPixelSet = async function() {
            log('üß™ Testing small pixel set (100 pixels)...');
            try {
                const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=*&limit=100`, {
                    headers: { 'apikey': CONFIG.SUPABASE_ANON_KEY, 'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}` }
                });
                const pixels = await response.json();
                log(`‚úÖ Small set: ${pixels.length} pixels loaded successfully`);
            } catch (error) {
                log(`‚ùå Small set failed: ${error.message}`);
            }
        };
        
        window.testMediumPixelSet = async function() {
            log('üß™ Testing medium pixel set (1000 pixels)...');
            try {
                const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=*&limit=1000`, {
                    headers: { 'apikey': CONFIG.SUPABASE_ANON_KEY, 'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}` }
                });
                const pixels = await response.json();
                log(`‚úÖ Medium set: ${pixels.length} pixels loaded successfully`);
            } catch (error) {
                log(`‚ùå Medium set failed: ${error.message}`);
            }
        };
        
        window.testLargePixelSet = async function() {
            log('üß™ Testing large pixel set (10000 pixels)...');
            try {
                const startTime = performance.now();
                const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=*&limit=10000`, {
                    headers: { 'apikey': CONFIG.SUPABASE_ANON_KEY, 'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}` }
                });
                const pixels = await response.json();
                const loadTime = performance.now() - startTime;
                log(`‚úÖ Large set: ${pixels.length} pixels loaded in ${loadTime.toFixed(0)}ms`);
                
                // Test if browser is still responsive
                setTimeout(() => {
                    log('‚úÖ Browser still responsive after large load');
                }, 100);
                
            } catch (error) {
                log(`‚ùå Large set failed: ${error.message}`);
            }
        };
        
        window.testMovement = function() {
            log('üß™ Testing simulated movement...');
            let moveCount = 0;
            const moveInterval = setInterval(() => {
                moveCount++;
                log(`Movement test ${moveCount}/10`);
                
                if (moveCount >= 10) {
                    clearInterval(moveInterval);
                    log('‚úÖ Movement test completed - browser responsive');
                }
            }, 100);
        };
        
        window.clearLog = function() {
            document.getElementById('testLog').innerHTML = '';
        };
        
        // Auto-start tests
        document.addEventListener('DOMContentLoaded', runDiagnosticTests);
    </script>
</body>
</html>