<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelCanvas è‡ªå‹•ç›£è¦–ãƒ»ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 10px;
            font-size: 11px;
        }
        .header {
            background: #1a1a1a;
            padding: 8px;
            border: 1px solid #00ff00;
            margin-bottom: 10px;
            text-align: center;
            font-size: 14px;
        }
        .monitoring-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .monitor-section {
            background: #111;
            border: 1px solid #333;
            padding: 8px;
            border-radius: 3px;
        }
        .monitor-title {
            color: #ffff00;
            font-weight: bold;
            margin-bottom: 6px;
            font-size: 12px;
        }
        .status-good { color: #44ff44; }
        .status-warning { color: #ffaa44; }
        .status-error { color: #ff4444; }
        .status-info { color: #4488ff; }
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 8px;
            height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 10px;
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        button {
            background: #1a1a1a;
            color: #00ff00;
            border: 1px solid #333;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 10px;
            font-family: inherit;
        }
        button:hover {
            background: #333;
            border-color: #00ff00;
        }
        .fix-counter {
            background: #1a1a1a;
            border: 2px solid #666;
            padding: 10px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
        }
        .auto-fix-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #2a2a2a;
            color: #00ff00;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 10px;
        }
        .pulse {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ”„ PixelCanvas è‡ªå‹•ç›£è¦–ãƒ»ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ </h1>
        <div>ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆã®ç¶™ç¶šçš„å“è³ªç®¡ç†ã¨è‡ªå‹•ä¿®æ­£</div>
    </div>

    <div class="auto-fix-indicator" id="autoFixIndicator">
        ğŸ”„ ç›£è¦–ä¸­...
    </div>

    <div class="monitoring-grid">
        <div class="monitor-section">
            <div class="monitor-title">ğŸ¯ ã‚¢ãƒ—ãƒªçŠ¶æ…‹ç›£è¦–</div>
            <div id="app-status">åˆæœŸåŒ–ä¸­...</div>
        </div>
        <div class="monitor-section">
            <div class="monitor-title">ğŸ¨ æç”»ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–</div>
            <div id="render-status">ç¢ºèªä¸­...</div>
        </div>
        <div class="monitor-section">
            <div class="monitor-title">ğŸ“Š ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–</div>
            <div id="data-status">æ¤œè¨¼ä¸­...</div>
        </div>
        <div class="monitor-section">
            <div class="monitor-title">âš¡ æ€§èƒ½ç›£è¦–</div>
            <div id="performance-status">æ¸¬å®šä¸­...</div>
        </div>
    </div>

    <div class="controls">
        <button onclick="startAutoMonitoring()">ğŸš€ è‡ªå‹•ç›£è¦–é–‹å§‹</button>
        <button onclick="stopAutoMonitoring()">â¹ï¸ åœæ­¢</button>
        <button onclick="forceCheck()">ğŸ” å³åº§ç¢ºèª</button>
        <button onclick="performAutoFix()">ğŸ”§ æ‰‹å‹•ä¿®æ­£å®Ÿè¡Œ</button>
        <button onclick="clearLogs()">ğŸ—‘ï¸ ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
    </div>

    <div class="log-area" id="logArea"></div>

    <div class="fix-counter" id="fixCounter">
        å®Ÿè¡Œä¿®æ­£æ•°: 0 | æ¤œå‡ºå•é¡Œæ•°: 0 | æ­£å¸¸ç¨¼åƒç‡: 100%
    </div>

    <script>
        let monitoringInterval = null;
        let isMonitoring = false;
        let fixCount = 0;
        let issueCount = 0;
        let checkCount = 0;
        let successCount = 0;

        const logArea = document.getElementById('logArea');
        const autoFixIndicator = document.getElementById('autoFixIndicator');
        const fixCounter = document.getElementById('fixCounter');

        const appStatus = document.getElementById('app-status');
        const renderStatus = document.getElementById('render-status');
        const dataStatus = document.getElementById('data-status');
        const performanceStatus = document.getElementById('performance-status');

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'good': '#44ff44',
                'warning': '#ffaa44',
                'error': '#ff4444',
                'info': '#4488ff'
            };
            
            const color = colors[type] || '#00ff00';
            logArea.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}\\n</span>`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function updateFixCounter() {
            const uptime = checkCount > 0 ? Math.round((successCount / checkCount) * 100) : 100;
            fixCounter.innerHTML = `å®Ÿè¡Œä¿®æ­£æ•°: ${fixCount} | æ¤œå‡ºå•é¡Œæ•°: ${issueCount} | æ­£å¸¸ç¨¼åƒç‡: ${uptime}%`;
        }

        function clearLogs() {
            logArea.innerHTML = '';
            log('ãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†', 'info');
        }

        // ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆPixelCanvasã®ç›£è¦–
        async function monitorDeployedApp() {
            checkCount++;
            
            try {
                log('ğŸ” ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç¢ºèªä¸­...', 'info');
                
                // ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‚’æ–°ã—ã„Windowã§é–‹ã„ã¦ç›£è¦–
                const appWindow = window.open('https://nikomori0320.github.io/pixcel_canvas/', '_blank');
                
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                let appWorking = false;
                let pixelCount = 0;
                let hasErrors = false;
                
                try {
                    // ã‚¢ãƒ—ãƒªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®çŠ¶æ…‹ç¢ºèª
                    if (appWindow && !appWindow.closed) {
                        const pixelCanvas = appWindow.pixelCanvas;
                        
                        if (pixelCanvas) {
                            appWorking = true;
                            const stats = pixelCanvas.getStats();
                            pixelCount = stats.data?.core?.totalPixels || 0;
                            
                            appStatus.innerHTML = '<span class="status-good">âœ… æ­£å¸¸å‹•ä½œ</span>';
                            renderStatus.innerHTML = '<span class="status-good">âœ… æç”»OK</span>';
                            dataStatus.innerHTML = `<span class="status-good">âœ… ãƒ‡ãƒ¼ã‚¿: ${pixelCount}px</span>`;
                            
                            log(`âœ… ã‚¢ãƒ—ãƒªæ­£å¸¸å‹•ä½œ: ${pixelCount}ãƒ”ã‚¯ã‚»ãƒ«`, 'good');
                            successCount++;
                        } else {
                            throw new Error('PixelCanvas ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        }
                        
                        appWindow.close();
                    } else {
                        throw new Error('ã‚¢ãƒ—ãƒªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ');
                    }
                    
                } catch (error) {
                    hasErrors = true;
                    issueCount++;
                    
                    appStatus.innerHTML = '<span class="status-error">âŒ ã‚¨ãƒ©ãƒ¼</span>';
                    renderStatus.innerHTML = '<span class="status-warning">âš ï¸ è¦ç¢ºèª</span>';
                    dataStatus.innerHTML = '<span class="status-error">âŒ ãƒ‡ãƒ¼ã‚¿ç•°å¸¸</span>';
                    
                    log(`âŒ ã‚¢ãƒ—ãƒªã‚¨ãƒ©ãƒ¼æ¤œå‡º: ${error.message}`, 'error');
                    
                    // è‡ªå‹•ä¿®æ­£å®Ÿè¡Œ
                    await performAutoFix();
                    
                    if (appWindow && !appWindow.closed) {
                        appWindow.close();
                    }
                }
                
            } catch (error) {
                issueCount++;
                log(`ğŸš¨ ç›£è¦–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                
                appStatus.innerHTML = '<span class="status-error">âŒ ç›£è¦–å¤±æ•—</span>';
                renderStatus.innerHTML = '<span class="status-error">âŒ ç¢ºèªä¸å¯</span>';
                dataStatus.innerHTML = '<span class="status-error">âŒ ç¢ºèªä¸å¯</span>';
                performanceStatus.innerHTML = '<span class="status-error">âŒ ç¢ºèªä¸å¯</span>';
            }
            
            updateFixCounter();
        }

        // è‡ªå‹•ä¿®æ­£ã®å®Ÿè¡Œ
        async function performAutoFix() {
            log('ğŸ”§ è‡ªå‹•ä¿®æ­£ãƒ—ãƒ­ã‚»ã‚¹é–‹å§‹...', 'info');
            fixCount++;
            
            try {
                // 1. verify-fix.htmlã§è©³ç´°è¨ºæ–­
                log('ğŸ“‹ è©³ç´°è¨ºæ–­å®Ÿè¡Œä¸­...', 'info');
                const verifyWindow = window.open('./verify-fix.html', '_blank');
                
                // è¨ºæ–­å®Œäº†ã¾ã§å¾…æ©Ÿ
                await new Promise(resolve => setTimeout(resolve, 5000));
                
                if (verifyWindow && !verifyWindow.closed) {
                    verifyWindow.close();
                }
                
                // 2. å¯èƒ½ãªä¿®æ­£ã‚’å®Ÿè¡Œ
                log('ğŸ”¨ ä¿®æ­£å‡¦ç†å®Ÿè¡Œä¸­...', 'info');
                
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    for (const cacheName of cacheNames) {
                        await caches.delete(cacheName);
                    }
                    log('ğŸ—‘ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å®Œäº†', 'good');
                }
                
                // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ˆå¿…è¦æœ€å°é™ï¼‰
                const keysToRemove = [
                    'pixelcanvas_debug',
                    'pixelcanvas_renderer_mode',
                    'pixelcanvas_use_pixi'
                ];
                
                keysToRemove.forEach(key => {
                    if (localStorage.getItem(key)) {
                        localStorage.removeItem(key);
                        log(`ğŸ§¹ ${key} è¨­å®šãƒªã‚»ãƒƒãƒˆ`, 'good');
                    }
                });
                
                log('âœ… è‡ªå‹•ä¿®æ­£å®Œäº†', 'good');
                
            } catch (error) {
                log(`âŒ è‡ªå‹•ä¿®æ­£å¤±æ•—: ${error.message}`, 'error');
            }
            
            updateFixCounter();
        }

        // è‡ªå‹•ç›£è¦–é–‹å§‹
        function startAutoMonitoring() {
            if (isMonitoring) {
                log('âš ï¸ æ—¢ã«ç›£è¦–ä¸­ã§ã™', 'warning');
                return;
            }
            
            isMonitoring = true;
            autoFixIndicator.innerHTML = 'ğŸ”„ è‡ªå‹•ç›£è¦–ä¸­...';
            autoFixIndicator.classList.add('pulse');
            
            log('ğŸš€ è‡ªå‹•ç›£è¦–é–‹å§‹', 'good');
            
            // å³åº§ã«1å›å®Ÿè¡Œ
            monitorDeployedApp();
            
            // 30ç§’é–“éš”ã§ç¶™ç¶šç›£è¦–
            monitoringInterval = setInterval(monitorDeployedApp, 30000);
        }

        // è‡ªå‹•ç›£è¦–åœæ­¢
        function stopAutoMonitoring() {
            if (!isMonitoring) {
                log('âš ï¸ ç›£è¦–ã¯å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                return;
            }
            
            isMonitoring = false;
            autoFixIndicator.innerHTML = 'â¹ï¸ åœæ­¢ä¸­';
            autoFixIndicator.classList.remove('pulse');
            
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }
            
            log('â¹ï¸ è‡ªå‹•ç›£è¦–åœæ­¢', 'info');
        }

        // å³åº§ç¢ºèª
        function forceCheck() {
            log('ğŸ” æ‰‹å‹•ç¢ºèªå®Ÿè¡Œ', 'info');
            monitorDeployedApp();
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«è‡ªå‹•é–‹å§‹
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('ğŸ”„ è‡ªå‹•ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†', 'info');
                log('ğŸš€ 30ç§’é–“éš”ã®è‡ªå‹•ç›£è¦–ã‚’é–‹å§‹ã—ã¾ã™...', 'info');
                startAutoMonitoring();
            }, 2000);
        });

        // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        window.addEventListener('beforeunload', () => {
            stopAutoMonitoring();
        });

    </script>
</body>
</html>