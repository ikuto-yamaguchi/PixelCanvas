<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelCanvas è‡ªå‹•ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 15px;
            font-size: 12px;
        }
        .system-header {
            background: #1a1a1a;
            padding: 10px;
            border: 2px solid #00ff00;
            margin-bottom: 15px;
            text-align: center;
        }
        .status-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .panel {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 3px;
        }
        .panel-title {
            color: #ffff00;
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        .issue { color: #ff4444; }
        .warning { color: #ffaa44; }
        .success { color: #44ff44; }
        .info { color: #4488ff; }
        .critical { background: #330000; border-color: #ff0000; }
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 11px;
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        button {
            background: #1a1a1a;
            color: #00ff00;
            border: 1px solid #333;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            font-family: inherit;
        }
        button:hover {
            background: #333;
            border-color: #00ff00;
        }
        button.critical {
            background: #330000;
            color: #ff4444;
            border-color: #ff0000;
        }
        .fix-progress {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 8px;
            margin-bottom: 10px;
        }
        .progress-bar {
            background: #333;
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            background: #00ff00;
            height: 100%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="system-header">
        <h1>ğŸ¤– PixelCanvas è‡ªå‹•ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  v2.0</h1>
        <div>ç¶™ç¶šçš„ç›£è¦–ãƒ»è¨ºæ–­ãƒ»ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ </div>
    </div>

    <div class="status-panel">
        <div class="panel">
            <div class="panel-title">ğŸ¯ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹</div>
            <div id="app-status"></div>
        </div>
        <div class="panel">
            <div class="panel-title">ğŸ¨ æç”»ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹</div>
            <div id="render-status"></div>
        </div>
        <div class="panel">
            <div class="panel-title">ğŸ“Š ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹</div>
            <div id="data-status"></div>
        </div>
        <div class="panel">
            <div class="panel-title">âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çŠ¶æ…‹</div>
            <div id="performance-status"></div>
        </div>
    </div>

    <div class="fix-progress">
        <div>ä¿®æ­£é€²è¡ŒçŠ¶æ³: <span id="fix-status">å¾…æ©Ÿä¸­</span></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
    </div>

    <div class="controls">
        <button onclick="startContinuousAnalysis()">ğŸ” ç¶™ç¶šåˆ†æé–‹å§‹</button>
        <button onclick="stopAnalysis()">â¹ï¸ åˆ†æåœæ­¢</button>
        <button onclick="runEmergencyFix()" class="critical">ğŸš¨ ç·Šæ€¥ä¿®æ­£å®Ÿè¡Œ</button>
        <button onclick="testPixelDrawing()">ğŸ¨ æç”»ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="clearLog()">ğŸ—‘ï¸ ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
    </div>

    <div class="log-area" id="log-area"></div>

    <script type="module">
        let analysisInterval = null;
        let fixAttempts = 0;
        let lastKnownIssues = new Set();
        let isFixing = false;

        const logArea = document.getElementById('log-area');
        const appStatus = document.getElementById('app-status');
        const renderStatus = document.getElementById('render-status');
        const dataStatus = document.getElementById('data-status');
        const performanceStatus = document.getElementById('performance-status');
        const fixStatus = document.getElementById('fix-status');
        const progressFill = document.getElementById('progress-fill');

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'issue': '#ff4444',
                'warning': '#ffaa44', 
                'success': '#44ff44',
                'info': '#4488ff',
                'critical': '#ff0000'
            };
            
            const color = colors[type] || '#00ff00';
            const entry = `[${timestamp}] ${message}\n`;
            
            console.log(message);
            logArea.innerHTML += `<span style="color: ${color}">${entry}</span>`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function clearLog() {
            logArea.innerHTML = '';
        }

        function updateProgress(percent, status) {
            progressFill.style.width = `${percent}%`;
            fixStatus.textContent = status;
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹åˆ†æ
        async function analyzeAppState() {
            const issues = [];
            let status = 'æ­£å¸¸';

            try {
                // PixelCanvas ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç¢ºèª
                if (!window.pixelCanvas) {
                    issues.push('PixelCanvasæœªåˆæœŸåŒ–');
                    status = 'ç•°å¸¸';
                } else {
                    const stats = window.pixelCanvas.getStats();
                    if (!stats.initialized) {
                        issues.push('åˆæœŸåŒ–æœªå®Œäº†');
                        status = 'ç•°å¸¸';
                    }
                }

                // DOMè¦ç´ ç¢ºèª
                const canvas = document.getElementById('mainCanvas');
                if (!canvas) {
                    issues.push('Canvasè¦ç´ ãªã—');
                    status = 'ç•°å¸¸';
                }

                // ä¾å­˜é–¢ä¿‚ç¢ºèª
                if (!window.PIXI) {
                    issues.push('PixiJSæœªãƒ­ãƒ¼ãƒ‰');
                }
                if (!window.supabase) {
                    issues.push('Supabaseæœªãƒ­ãƒ¼ãƒ‰');
                }

            } catch (error) {
                issues.push(`åˆ†æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                status = 'ç•°å¸¸';
            }

            appStatus.innerHTML = `
                <div class="${status === 'æ­£å¸¸' ? 'success' : 'issue'}">çŠ¶æ…‹: ${status}</div>
                ${issues.map(issue => `<div class="issue">âš ï¸ ${issue}</div>`).join('')}
            `;

            return { status, issues };
        }

        // æç”»ã‚·ã‚¹ãƒ†ãƒ åˆ†æ
        async function analyzeRenderSystem() {
            const issues = [];
            let status = 'ä¸æ˜';

            try {
                const canvas = document.getElementById('mainCanvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        // Canvasæç”»ãƒ†ã‚¹ãƒˆ
                        const imageData = ctx.getImageData(0, 0, 1, 1);
                        status = 'æ­£å¸¸';
                        
                        // ãƒ”ã‚¯ã‚»ãƒ«æç”»ç¢ºèª
                        if (window.pixelCanvas) {
                            const stats = window.pixelCanvas.getStats();
                            const pixelCount = stats.data?.totalPixels || 0;
                            
                            if (pixelCount === 0) {
                                issues.push('ãƒ”ã‚¯ã‚»ãƒ«æœªãƒ­ãƒ¼ãƒ‰');
                                status = 'ç•°å¸¸';
                            } else {
                                log(`ãƒ¡ãƒ¢ãƒªå†…ãƒ”ã‚¯ã‚»ãƒ«æ•°: ${pixelCount}`, 'success');
                            }
                        }
                    } else {
                        issues.push('Canvas Contextå–å¾—å¤±æ•—');
                        status = 'ç•°å¸¸';
                    }
                } else {
                    issues.push('Canvasè¦ç´ ãªã—');
                    status = 'ç•°å¸¸';
                }
            } catch (error) {
                issues.push(`æç”»åˆ†æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                status = 'ç•°å¸¸';
            }

            renderStatus.innerHTML = `
                <div class="${status === 'æ­£å¸¸' ? 'success' : 'issue'}">çŠ¶æ…‹: ${status}</div>
                ${issues.map(issue => `<div class="issue">âš ï¸ ${issue}</div>`).join('')}
            `;

            return { status, issues };
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ åˆ†æ
        async function analyzeDataSystem() {
            const issues = [];
            let status = 'æ­£å¸¸';

            try {
                // Supabaseæ¥ç¶šãƒ†ã‚¹ãƒˆ
                const response = await fetch('https://lgvjdefkyeuvquzckkvb.supabase.co/rest/v1/pixels?select=count&limit=1', {
                    headers: {
                        'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY',
                        'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY'
                    }
                });

                if (!response.ok) {
                    issues.push(`Supabaseæ¥ç¶šå¤±æ•—: ${response.status}`);
                    status = 'ç•°å¸¸';
                }

                // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ç¢ºèª
                if (window.pixelCanvas) {
                    const stats = window.pixelCanvas.getStats();
                    if (stats.data?.totalPixels === 0) {
                        issues.push('ãƒ‡ãƒ¼ã‚¿æœªãƒ­ãƒ¼ãƒ‰');
                        status = 'ç•°å¸¸';
                    }
                }

            } catch (error) {
                issues.push(`ãƒ‡ãƒ¼ã‚¿åˆ†æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                status = 'ç•°å¸¸';
            }

            dataStatus.innerHTML = `
                <div class="${status === 'æ­£å¸¸' ? 'success' : 'issue'}">çŠ¶æ…‹: ${status}</div>
                ${issues.map(issue => `<div class="issue">âš ï¸ ${issue}</div>`).join('')}
            `;

            return { status, issues };
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
        async function analyzePerformance() {
            const issues = [];
            let status = 'æ­£å¸¸';

            try {
                // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç¢ºèª
                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    if (memoryMB > 200) {
                        issues.push(`é«˜ãƒ¡ãƒ¢ãƒªä½¿ç”¨: ${memoryMB}MB`);
                        status = 'è­¦å‘Š';
                    }
                }

                // å¿œç­”æ™‚é–“ãƒ†ã‚¹ãƒˆ
                const start = performance.now();
                await new Promise(resolve => setTimeout(resolve, 10));
                const responseTime = performance.now() - start;
                
                if (responseTime > 50) {
                    issues.push(`å¿œç­”é…å»¶: ${responseTime.toFixed(2)}ms`);
                    status = 'è­¦å‘Š';
                }

            } catch (error) {
                issues.push(`ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                status = 'ç•°å¸¸';
            }

            performanceStatus.innerHTML = `
                <div class="${status === 'æ­£å¸¸' ? 'success' : status === 'è­¦å‘Š' ? 'warning' : 'issue'}">çŠ¶æ…‹: ${status}</div>
                ${issues.map(issue => `<div class="warning">âš ï¸ ${issue}</div>`).join('')}
            `;

            return { status, issues };
        }

        // åŒ…æ‹¬çš„åˆ†æå®Ÿè¡Œ
        async function runComprehensiveAnalysis() {
            log('ğŸ” åŒ…æ‹¬çš„åˆ†æã‚’é–‹å§‹...', 'info');

            const results = await Promise.all([
                analyzeAppState(),
                analyzeRenderSystem(), 
                analyzeDataSystem(),
                analyzePerformance()
            ]);

            const allIssues = results.flatMap(result => result.issues);
            const criticalIssues = allIssues.filter(issue => 
                issue.includes('æœªåˆæœŸåŒ–') || 
                issue.includes('æœªãƒ­ãƒ¼ãƒ‰') || 
                issue.includes('Canvasè¦ç´ ãªã—')
            );

            if (criticalIssues.length > 0) {
                log(`ğŸš¨ è‡´å‘½çš„å•é¡Œæ¤œå‡º: ${criticalIssues.length}ä»¶`, 'critical');
                return await attemptAutomaticFix(criticalIssues);
            } else if (allIssues.length > 0) {
                log(`âš ï¸ å•é¡Œæ¤œå‡º: ${allIssues.length}ä»¶`, 'warning');
                allIssues.forEach(issue => log(`  - ${issue}`, 'warning'));
            } else {
                log('âœ… å…¨ã‚·ã‚¹ãƒ†ãƒ æ­£å¸¸', 'success');
            }

            return allIssues.length === 0;
        }

        // è‡ªå‹•ä¿®æ­£è©¦è¡Œ
        async function attemptAutomaticFix(issues) {
            if (isFixing) {
                log('ğŸ”§ ä¿®æ­£å‡¦ç†ä¸­...', 'warning');
                return false;
            }

            isFixing = true;
            fixAttempts++;
            log(`ğŸ”§ è‡ªå‹•ä¿®æ­£é–‹å§‹ (è©¦è¡Œ ${fixAttempts})`, 'info');

            try {
                updateProgress(10, 'ä¿®æ­£æº–å‚™ä¸­...');

                // PixelCanvaså†åˆæœŸåŒ–
                if (issues.some(issue => issue.includes('æœªåˆæœŸåŒ–'))) {
                    updateProgress(30, 'PixelCanvaså†åˆæœŸåŒ–ä¸­...');
                    await reinitializePixelCanvas();
                }

                updateProgress(50, 'ãƒ‡ãƒ¼ã‚¿å†èª­ã¿è¾¼ã¿ä¸­...');
                // ãƒ‡ãƒ¼ã‚¿å¼·åˆ¶å†èª­ã¿è¾¼ã¿
                if (window.pixelCanvas && window.pixelCanvas.pixelDataManager) {
                    await window.pixelCanvas.pixelDataManager.forceReload();
                }

                updateProgress(70, 'ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¼·åˆ¶å®Ÿè¡Œä¸­...');
                // å¼·åˆ¶ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                if (window.pixelCanvas) {
                    window.pixelCanvas.render();
                }

                updateProgress(90, 'æ¤œè¨¼ä¸­...');
                // ä¿®æ­£çµæœç¢ºèª
                await new Promise(resolve => setTimeout(resolve, 1000));
                const success = await runComprehensiveAnalysis();

                updateProgress(100, success ? 'ä¿®æ­£å®Œäº†' : 'ä¿®æ­£å¤±æ•—');
                
                if (success) {
                    log('âœ… è‡ªå‹•ä¿®æ­£æˆåŠŸ', 'success');
                } else {
                    log('âŒ è‡ªå‹•ä¿®æ­£å¤±æ•— - æ‰‹å‹•ä»‹å…¥ãŒå¿…è¦', 'issue');
                }

                return success;

            } catch (error) {
                log(`âŒ ä¿®æ­£ä¸­ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'critical');
                return false;
            } finally {
                isFixing = false;
                setTimeout(() => updateProgress(0, 'å¾…æ©Ÿä¸­'), 2000);
            }
        }

        // PixelCanvaså†åˆæœŸåŒ–
        async function reinitializePixelCanvas() {
            try {
                if (window.pixelCanvasApp) {
                    await window.pixelCanvasApp.reinitialize();
                    log('ğŸ”„ PixelCanvaså†åˆæœŸåŒ–å®Œäº†', 'success');
                } else {
                    // ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆå†èª­ã¿è¾¼ã¿
                    const script = document.createElement('script');
                    script.type = 'module';
                    script.src = 'main.js';
                    document.head.appendChild(script);
                    log('ğŸ”„ ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆå†èª­ã¿è¾¼ã¿', 'info');
                }
            } catch (error) {
                log(`âŒ å†åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'issue');
            }
        }

        // ãƒ”ã‚¯ã‚»ãƒ«æç”»ãƒ†ã‚¹ãƒˆ
        async function testPixelDrawing() {
            log('ğŸ¨ æç”»ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...', 'info');

            try {
                const canvas = document.getElementById('mainCanvas');
                if (!canvas) {
                    log('âŒ Canvasè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'issue');
                    return false;
                }

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    log('âŒ Canvas ContextãŒå–å¾—ã§ãã¾ã›ã‚“', 'issue');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆæç”»
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(10, 10, 20, 20);
                log('âœ… ãƒ†ã‚¹ãƒˆæç”»å®Œäº†', 'success');

                // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ç¢ºèª
                const imageData = ctx.getImageData(10, 10, 1, 1);
                const hasData = imageData.data[0] > 0;
                log(`ğŸ“Š æç”»ç¢ºèª: ${hasData ? 'æˆåŠŸ' : 'å¤±æ•—'}`, hasData ? 'success' : 'issue');

                return hasData;

            } catch (error) {
                log(`âŒ æç”»ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'issue');
                return false;
            }
        }

        // ç¶™ç¶šåˆ†æé–‹å§‹
        function startContinuousAnalysis() {
            if (analysisInterval) {
                log('âš ï¸ æ—¢ã«åˆ†æå®Ÿè¡Œä¸­ã§ã™', 'warning');
                return;
            }

            log('ğŸš€ ç¶™ç¶šåˆ†æã‚’é–‹å§‹ã—ã¾ã™', 'info');
            
            // åˆå›å®Ÿè¡Œ
            runComprehensiveAnalysis();
            
            // 30ç§’é–“éš”ã§ç¶™ç¶šå®Ÿè¡Œ
            analysisInterval = setInterval(() => {
                runComprehensiveAnalysis();
            }, 30000);
        }

        // åˆ†æåœæ­¢
        function stopAnalysis() {
            if (analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
                log('â¹ï¸ ç¶™ç¶šåˆ†æã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info');
            }
        }

        // ç·Šæ€¥ä¿®æ­£å®Ÿè¡Œ
        async function runEmergencyFix() {
            log('ğŸš¨ ç·Šæ€¥ä¿®æ­£ã‚’é–‹å§‹ã—ã¾ã™', 'critical');
            
            const mockIssues = ['PixelCanvasæœªåˆæœŸåŒ–', 'ãƒ‡ãƒ¼ã‚¿æœªãƒ­ãƒ¼ãƒ‰'];
            await attemptAutomaticFix(mockIssues);
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
        window.startContinuousAnalysis = startContinuousAnalysis;
        window.stopAnalysis = stopAnalysis;
        window.runEmergencyFix = runEmergencyFix;
        window.testPixelDrawing = testPixelDrawing;
        window.clearLog = clearLog;

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«è‡ªå‹•é–‹å§‹
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('ğŸ¤– è‡ªå‹•ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•', 'success');
                startContinuousAnalysis();
            }, 2000);
        });

    </script>
</body>
</html>