// ğŸ¨ Ultra Fast Rendering Engine
// Target: 60fps with intelligent LOD + dirty region rendering

import { CONFIG } from './Config.js';

export class UltraFastRenderer {
    constructor(canvas, pixelStorage) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.pixelStorage = pixelStorage;
        
        // ImageData cache for ultra-fast pixel manipulation
        this.imageData = null;
        this.data = null;
        this.width = 0;
        this.height = 0;
        
        // LOD system
        this.currentLOD = 0;
        this.lodThresholds = [8.0, 4.0, 2.0, 1.0, 0.5]; // scale thresholds
        
        // Performance optimization
        this.renderQueue = [];
        this.dirtyRegions = new Set();
        this.isRendering = false;
        this.lastRenderTime = 0;
        this.targetFPS = 60;
        this.frameTime = 1000 / this.targetFPS;
        
        // Color palette (pre-computed RGBA values)
        this.paletteRGBA = this.createPaletteCache();
        
        // Statistics
        this.stats = {
            frameCount: 0,
            averageFPS: 0,
            averageRenderTime: 0,
            pixelsRendered: 0,
            lodLevel: 0
        };
        
        // Viewport cache
        this.lastViewport = null;
        this.viewportChanged = true;
    }
    
    // ğŸ¨ ãƒ¡ã‚¤ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•° (æœ€é©åŒ–æ¸ˆã¿)
    render(viewport, scale) {\n        const renderStartTime = performance.now();
        \n        // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶é™\n        if (renderStartTime - this.lastRenderTime < this.frameTime) {\n            return; // Skip frame to maintain target FPS\n        }\n        \n        try {\n            // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›´æ¤œå‡º\n            this.detectViewportChange(viewport);\n            \n            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´\n            this.resizeIfNeeded(viewport.width, viewport.height);\n            \n            // LODãƒ¬ãƒ™ãƒ«è¨ˆç®—\n            const lodLevel = this.calculateLOD(scale);\n            this.currentLOD = lodLevel;\n            \n            // é©å¿œçš„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æˆ¦ç•¥é¸æŠ\n            if (this.viewportChanged) {\n                this.renderFullViewport(viewport, scale, lodLevel);\n            } else if (this.dirtyRegions.size > 0) {\n                this.renderDirtyRegions(viewport, scale, lodLevel);\n            }\n            \n            // çµ±è¨ˆæ›´æ–°\n            this.updateStats(renderStartTime);\n            \n            this.lastRenderTime = renderStartTime;\n            \n        } catch (error) {\n            console.error('âŒ Render error:', error);\n        }\n    }\n    \n    // ğŸ” LODãƒ¬ãƒ™ãƒ«è¨ˆç®— (é©å¿œçš„)\n    calculateLOD(scale) {\n        for (let i = 0; i < this.lodThresholds.length; i++) {\n            if (scale >= this.lodThresholds[i]) {\n                return i;\n            }\n        }\n        return this.lodThresholds.length;\n    }\n    \n    // ğŸ–¼ï¸ ãƒ•ãƒ«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°\n    renderFullViewport(viewport, scale, lodLevel) {\n        console.log(`ğŸ¨ Full render: LOD${lodLevel}, scale: ${scale.toFixed(2)}`);\n        \n        // èƒŒæ™¯ã‚¯ãƒªã‚¢\n        this.clearCanvas();\n        \n        // LODã«å¿œã˜ãŸãƒ”ã‚¯ã‚»ãƒ«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°\n        const skipFactor = Math.pow(2, lodLevel);\n        const maxPixels = this.getMaxPixelsForLOD(lodLevel);\n        \n        // è¡¨ç¤ºç¯„å›²å†…ã®ãƒ”ã‚¯ã‚»ãƒ«å–å¾—\n        const visiblePixels = this.getVisiblePixels(viewport, scale);\n        \n        // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° + ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°\n        this.renderPixelsBatch(visiblePixels, viewport, scale, skipFactor, maxPixels);\n        \n        this.viewportChanged = false;\n        this.stats.pixelsRendered = Math.min(visiblePixels.length, maxPixels);\n    }\n    \n    // ğŸ¯ å·®åˆ†é ˜åŸŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°\n    renderDirtyRegions(viewport, scale, lodLevel) {\n        console.log(`ğŸ¯ Dirty render: ${this.dirtyRegions.size} regions`);\n        \n        for (const region of this.dirtyRegions) {\n            this.renderRegion(region, viewport, scale, lodLevel);\n        }\n        \n        this.dirtyRegions.clear();\n    }\n    \n    // ğŸ”¥ è¶…é«˜é€Ÿãƒ”ã‚¯ã‚»ãƒ«ãƒãƒƒãƒãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°\n    renderPixelsBatch(pixels, viewport, scale, skipFactor, maxPixels) {\n        let rendered = 0;\n        const pixelSize = Math.max(1, Math.floor(scale));\n        \n        // ImageDataã‚’ç›´æ¥æ“ä½œ\n        if (!this.data) return;\n        \n        for (let i = 0; i < pixels.length && rendered < maxPixels; i += skipFactor) {\n            const pixel = pixels[i];\n            \n            // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‹ã‚‰ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™\n            const screenX = Math.floor((pixel.worldX * scale) - viewport.x);\n            const screenY = Math.floor((pixel.worldY * scale) - viewport.y);\n            \n            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯\n            if (screenX >= -pixelSize && screenX < this.width + pixelSize && \n                screenY >= -pixelSize && screenY < this.height + pixelSize) {\n                \n                this.drawPixelFast(screenX, screenY, pixel.color, pixelSize);\n                rendered++;\n            }\n        }\n        \n        // ä¸€æ‹¬æ›´æ–°\n        this.ctx.putImageData(this.imageData, 0, 0);\n        \n        console.log(`âš¡ Rendered ${rendered} pixels (skip: ${skipFactor})`);\n    }\n    \n    // âš¡ è¶…é«˜é€Ÿãƒ”ã‚¯ã‚»ãƒ«æç”» (ImageDataç›´æ¥æ“ä½œ)\n    drawPixelFast(x, y, colorIndex, size) {\n        const color = this.paletteRGBA[colorIndex];\n        if (!color) return;\n        \n        // ã‚µã‚¤ã‚ºã«å¿œã˜ã¦æç”»\n        for (let dy = 0; dy < size; dy++) {\n            for (let dx = 0; dx < size; dx++) {\n                const px = x + dx;\n                const py = y + dy;\n                \n                if (px >= 0 && px < this.width && py >= 0 && py < this.height) {\n                    const index = (py * this.width + px) * 4;\n                    this.data[index] = color[0];     // R\n                    this.data[index + 1] = color[1]; // G\n                    this.data[index + 2] = color[2]; // B\n                    this.data[index + 3] = color[3]; // A\n                }\n            }\n        }\n    }\n    \n    // ğŸŒˆ ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä½œæˆ\n    createPaletteCache() {\n        const cache = [];\n        \n        for (let i = 0; i < CONFIG.PALETTE.length; i++) {\n            const hex = CONFIG.PALETTE[i];\n            const r = parseInt(hex.slice(1, 3), 16);\n            const g = parseInt(hex.slice(3, 5), 16);\n            const b = parseInt(hex.slice(5, 7), 16);\n            cache[i] = [r, g, b, 255];\n        }\n        \n        return cache;\n    }\n    \n    // ğŸ‘ï¸ è¡¨ç¤ºç¯„å›²ãƒ”ã‚¯ã‚»ãƒ«å–å¾—\n    getVisiblePixels(viewport, scale) {\n        // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã§ã®è¡¨ç¤ºç¯„å›²è¨ˆç®—\n        const worldMinX = Math.floor(viewport.x / scale);\n        const worldMinY = Math.floor(viewport.y / scale);\n        const worldMaxX = Math.ceil((viewport.x + viewport.width) / scale);\n        const worldMaxY = Math.ceil((viewport.y + viewport.height) / scale);\n        \n        const visiblePixels = [];\n        \n        // PixelStorageã‹ã‚‰ç¯„å›²å†…ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’å–å¾—\n        for (const [key, color] of this.pixelStorage.pixels) {\n            const [sectorX, sectorY, localX, localY] = key.split(',').map(Number);\n            const worldX = sectorX * CONFIG.GRID_SIZE + localX;\n            const worldY = sectorY * CONFIG.GRID_SIZE + localY;\n            \n            if (worldX >= worldMinX && worldX <= worldMaxX && \n                worldY >= worldMinY && worldY <= worldMaxY) {\n                visiblePixels.push({\n                    worldX,\n                    worldY,\n                    color,\n                    key\n                });\n            }\n        }\n        \n        return visiblePixels;\n    }\n    \n    // ğŸ“ ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´\n    resizeIfNeeded(width, height) {\n        if (this.width !== width || this.height !== height) {\n            this.width = width;\n            this.height = height;\n            \n            // ç‰©ç†ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºæ›´æ–°\n            const dpr = window.devicePixelRatio || 1;\n            this.canvas.width = width * dpr;\n            this.canvas.height = height * dpr;\n            this.canvas.style.width = width + 'px';\n            this.canvas.style.height = height + 'px';\n            \n            this.ctx.scale(dpr, dpr);\n            \n            // ImageDataå†ä½œæˆ\n            this.imageData = this.ctx.createImageData(width, height);\n            this.data = this.imageData.data;\n            \n            console.log(`ğŸ“ Canvas resized: ${width}x${height} (DPR: ${dpr})`);\n        }\n    }\n    \n    // ğŸ§¹ ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢\n    clearCanvas() {\n        if (this.data) {\n            // é«˜é€Ÿãƒ¡ãƒ¢ãƒªã‚¯ãƒªã‚¢\n            this.data.fill(0);\n        }\n    }\n    \n    // ğŸ¯ é ˜åŸŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°\n    renderRegion(region, viewport, scale, lodLevel) {\n        const regionPixels = this.getPixelsInRegion(region);\n        const skipFactor = Math.pow(2, lodLevel);\n        const maxPixels = 1000; // é ˜åŸŸã‚ãŸã‚Šã®æœ€å¤§ãƒ”ã‚¯ã‚»ãƒ«æ•°\n        \n        this.renderPixelsBatch(regionPixels, viewport, scale, skipFactor, maxPixels);\n    }\n    \n    // ğŸ“Š é ˜åŸŸå†…ãƒ”ã‚¯ã‚»ãƒ«å–å¾—\n    getPixelsInRegion(region) {\n        const pixels = [];\n        \n        for (const [key, color] of this.pixelStorage.pixels) {\n            const [sectorX, sectorY, localX, localY] = key.split(',').map(Number);\n            const worldX = sectorX * CONFIG.GRID_SIZE + localX;\n            const worldY = sectorY * CONFIG.GRID_SIZE + localY;\n            \n            if (worldX >= region.x && worldX < region.x + region.width &&\n                worldY >= region.y && worldY < region.y + region.height) {\n                pixels.push({ worldX, worldY, color, key });\n            }\n        }\n        \n        return pixels;\n    }\n    \n    // ğŸ” ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›´æ¤œå‡º\n    detectViewportChange(viewport) {\n        if (!this.lastViewport) {\n            this.viewportChanged = true;\n            this.lastViewport = { ...viewport };\n            return;\n        }\n        \n        const threshold = 10; // 10ãƒ”ã‚¯ã‚»ãƒ«ä»¥ä¸Šã®ç§»å‹•ã§å¤‰æ›´ã¨åˆ¤å®š\n        \n        this.viewportChanged = \n            Math.abs(viewport.x - this.lastViewport.x) > threshold ||\n            Math.abs(viewport.y - this.lastViewport.y) > threshold ||\n            viewport.width !== this.lastViewport.width ||\n            viewport.height !== this.lastViewport.height;\n            \n        if (this.viewportChanged) {\n            this.lastViewport = { ...viewport };\n        }\n    }\n    \n    // ğŸ¯ ãƒ€ãƒ¼ãƒ†ã‚£é ˜åŸŸè¿½åŠ \n    addDirtyRegion(x, y, width = 10, height = 10) {\n        this.dirtyRegions.add({\n            x: Math.max(0, x - 5),\n            y: Math.max(0, y - 5),\n            width: width + 10,\n            height: height + 10\n        });\n    }\n    \n    // ğŸ“Š LODãƒ¬ãƒ™ãƒ«åˆ¥æœ€å¤§ãƒ”ã‚¯ã‚»ãƒ«æ•°\n    getMaxPixelsForLOD(lodLevel) {\n        const maxPixels = [5000, 3000, 2000, 1000, 500, 250];\n        return maxPixels[lodLevel] || 100;\n    }\n    \n    // ğŸ“ˆ çµ±è¨ˆæ›´æ–°\n    updateStats(startTime) {\n        const renderTime = performance.now() - startTime;\n        this.stats.frameCount++;\n        this.stats.averageRenderTime = (this.stats.averageRenderTime + renderTime) / 2;\n        this.stats.lodLevel = this.currentLOD;\n        \n        // FPSè¨ˆç®— (1ç§’ã”ã¨)\n        if (this.stats.frameCount % 60 === 0) {\n            this.stats.averageFPS = 1000 / this.stats.averageRenderTime;\n            console.log(`ğŸ“Š FPS: ${this.stats.averageFPS.toFixed(1)}, Render: ${this.stats.averageRenderTime.toFixed(1)}ms, LOD: ${this.currentLOD}`);\n        }\n    }\n    \n    // ğŸ“Š çµ±è¨ˆæƒ…å ±å–å¾—\n    getStats() {\n        return {\n            ...this.stats,\n            targetFPS: this.targetFPS,\n            dirtyRegions: this.dirtyRegions.size,\n            isOptimal: this.stats.averageFPS >= this.targetFPS * 0.9\n        };\n    }\n    \n    // ğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n    cleanup() {\n        this.dirtyRegions.clear();\n        this.renderQueue = [];\n        this.imageData = null;\n        this.data = null;\n        \n        console.log('ğŸ§¹ UltraFastRenderer cleaned up');\n    }\n}