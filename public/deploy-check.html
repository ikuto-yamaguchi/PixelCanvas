<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelCanvas ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆç¢ºèªã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 10px;
            font-size: 11px;
        }
        .header {
            background: #1a1a1a;
            padding: 10px;
            border: 2px solid #00ff00;
            margin-bottom: 15px;
            text-align: center;
            font-size: 16px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .test-section {
            background: #111;
            border: 2px solid #333;
            padding: 12px;
            border-radius: 5px;
        }
        .test-title {
            color: #ffff00;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        .status-pass { color: #44ff44; }
        .status-fail { color: #ff4444; }
        .status-warning { color: #ffaa44; }
        .status-info { color: #4488ff; }
        .result-log {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 250px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 10px;
            margin-bottom: 15px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        button {
            background: #1a1a1a;
            color: #00ff00;
            border: 2px solid #333;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            font-family: inherit;
            border-radius: 3px;
        }
        button:hover {
            background: #333;
            border-color: #00ff00;
        }
        .summary {
            background: #1a1a1a;
            border: 3px solid #666;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .deploy-url {
            background: #2a2a2a;
            color: #00ffff;
            padding: 8px;
            border: 1px solid #00ffff;
            text-align: center;
            margin-bottom: 15px;
            word-break: break-all;
        }
        .iframe-container {
            border: 2px solid #333;
            height: 400px;
            margin-bottom: 15px;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸš€ PixelCanvas ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆç¢ºèªã‚·ã‚¹ãƒ†ãƒ </h1>
        <div>GitHub Pages ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆã®å‹•ä½œç¢ºèªã¨å“è³ªæ¤œè¨¼</div>
    </div>

    <div class="deploy-url">
        <strong>ãƒ‡ãƒ—ãƒ­ã‚¤URL:</strong> https://nikomori0320.github.io/pixcel_canvas/
    </div>

    <div class="test-grid">
        <div class="test-section">
            <div class="test-title">ğŸŒ ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹</div>
            <div id="deploy-results">ç¢ºèªä¸­...</div>
        </div>
        <div class="test-section">
            <div class="test-title">ğŸ¯ ã‚¢ãƒ—ãƒªåˆæœŸåŒ–</div>
            <div id="init-results">å¾…æ©Ÿä¸­...</div>
        </div>
        <div class="test-section">
            <div class="test-title">ğŸ¨ æç”»æ©Ÿèƒ½</div>
            <div id="render-results">å¾…æ©Ÿä¸­...</div>
        </div>
        <div class="test-section">
            <div class="test-title">ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</div>
            <div id="data-results">å¾…æ©Ÿä¸­...</div>
        </div>
        <div class="test-section">
            <div class="test-title">âš¡ æ€§èƒ½æ¸¬å®š</div>
            <div id="performance-results">å¾…æ©Ÿä¸­...</div>
        </div>
        <div class="test-section">
            <div class="test-title">ğŸ”§ ä¿®æ­£æ¨å¥¨</div>
            <div id="fix-results">å¾…æ©Ÿä¸­...</div>
        </div>
    </div>

    <div class="controls">
        <button onclick="startFullCheck()">ğŸš€ å®Œå…¨ç¢ºèªé–‹å§‹</button>
        <button onclick="checkDeployStatus()">ğŸŒ ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹ç¢ºèª</button>
        <button onclick="testAppFunctionality()">ğŸ¯ æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="measurePerformance()">âš¡ æ€§èƒ½æ¸¬å®š</button>
        <button onclick="generateFixReport()">ğŸ”§ ä¿®æ­£ãƒ¬ãƒãƒ¼ãƒˆ</button>
        <button onclick="openDeployedApp()">ğŸ“± ã‚¢ãƒ—ãƒªã‚’é–‹ã</button>
        <button onclick="clearResults()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
    </div>

    <div class="result-log" id="resultLog"></div>

    <div class="summary" id="summary">
        ç¢ºèªå¾…æ©Ÿä¸­...
    </div>

    <div class="iframe-container">
        <iframe id="deployFrame" src="about:blank"></iframe>
    </div>

    <script>
        const resultLog = document.getElementById('resultLog');
        const summary = document.getElementById('summary');
        
        const deployResults = document.getElementById('deploy-results');
        const initResults = document.getElementById('init-results');
        const renderResults = document.getElementById('render-results');
        const dataResults = document.getElementById('data-results');
        const performanceResults = document.getElementById('performance-results');
        const fixResults = document.getElementById('fix-results');

        let checkResults = {
            deploy: { status: 'pending', message: '' },
            init: { status: 'pending', message: '' },
            render: { status: 'pending', message: '' },
            data: { status: 'pending', message: '' },
            performance: { status: 'pending', message: '' },
            fixes: []
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'pass': '#44ff44',
                'fail': '#ff4444',
                'warning': '#ffaa44',
                'info': '#4488ff'
            };
            
            const color = colors[type] || '#00ff00';
            resultLog.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}\\n</span>`;
            resultLog.scrollTop = resultLog.scrollHeight;
        }

        function updateSummary() {
            const total = Object.keys(checkResults).filter(k => k !== 'fixes').length;
            const passed = Object.keys(checkResults).filter(k => k !== 'fixes' && checkResults[k].status === 'pass').length;
            const failed = Object.keys(checkResults).filter(k => k !== 'fixes' && checkResults[k].status === 'fail').length;
            
            const passRate = total > 0 ? Math.round((passed / total) * 100) : 0;
            
            summary.innerHTML = `
                ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆç¢ºèªçµæœ: ${passRate}% æˆåŠŸ 
                (âœ…${passed} âŒ${failed} ğŸ“‹${checkResults.fixes.length}ä¿®æ­£æ¨å¥¨)
            `;
            
            if (passRate >= 80) summary.className = 'summary status-pass';
            else if (passRate >= 60) summary.className = 'summary status-warning';
            else summary.className = 'summary status-fail';
        }

        function clearResults() {
            resultLog.innerHTML = '';
            Object.keys(checkResults).forEach(key => {
                if (key === 'fixes') {
                    checkResults[key] = [];
                } else {
                    checkResults[key] = { status: 'pending', message: '' };
                }
            });
            updateDisplay();
            log('çµæœã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        }

        function updateDisplay() {
            deployResults.innerHTML = formatResult(checkResults.deploy);
            initResults.innerHTML = formatResult(checkResults.init);
            renderResults.innerHTML = formatResult(checkResults.render);
            dataResults.innerHTML = formatResult(checkResults.data);
            performanceResults.innerHTML = formatResult(checkResults.performance);
            fixResults.innerHTML = checkResults.fixes.length > 0 ? 
                `<span class="status-warning">${checkResults.fixes.length}ä»¶ã®ä¿®æ­£æ¨å¥¨</span>` : 
                `<span class="status-pass">ä¿®æ­£ä¸è¦</span>`;
            updateSummary();
        }

        function formatResult(result) {
            const status = result.status;
            const message = result.message || 'ç¢ºèªä¸­...';
            
            if (status === 'pass') return `<span class="status-pass">âœ… ${message}</span>`;
            if (status === 'fail') return `<span class="status-fail">âŒ ${message}</span>`;
            if (status === 'warning') return `<span class="status-warning">âš ï¸ ${message}</span>`;
            return `<span class="status-info">ğŸ”„ ${message}</span>`;
        }

        // ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹ç¢ºèª
        async function checkDeployStatus() {
            log('ğŸŒ ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹ç¢ºèªé–‹å§‹...', 'info');
            
            try {
                const response = await fetch('https://nikomori0320.github.io/pixcel_canvas/');
                
                if (response.ok) {
                    const html = await response.text();
                    
                    // HTMLå†…å®¹ãƒã‚§ãƒƒã‚¯
                    if (html.includes('PixelCanvas') && html.includes('mainCanvas')) {
                        checkResults.deploy = { status: 'pass', message: 'ãƒ‡ãƒ—ãƒ­ã‚¤æˆåŠŸ' };
                        log('âœ… ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹: æ­£å¸¸', 'pass');
                    } else {
                        checkResults.deploy = { status: 'warning', message: 'å†…å®¹ã«å•é¡Œ' };
                        log('âš ï¸ ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹: å†…å®¹ã«å•é¡Œã‚ã‚Š', 'warning');
                    }
                } else {
                    checkResults.deploy = { status: 'fail', message: `HTTP ${response.status}` };
                    log(`âŒ ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹: HTTP ${response.status}`, 'fail');
                }
                
            } catch (error) {
                checkResults.deploy = { status: 'fail', message: 'ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯' };
                log(`âŒ ãƒ‡ãƒ—ãƒ­ã‚¤ç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'fail');
            }
            
            updateDisplay();
        }

        // ã‚¢ãƒ—ãƒªæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
        async function testAppFunctionality() {
            log('ğŸ¯ ã‚¢ãƒ—ãƒªæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹...', 'info');
            
            // iframeã§ã‚¢ãƒ—ãƒªã‚’èª­ã¿è¾¼ã‚“ã§ç¢ºèª
            const iframe = document.getElementById('deployFrame');
            iframe.src = 'https://nikomori0320.github.io/pixcel_canvas/';
            
            // èª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å¾…æ©Ÿ
            await new Promise(resolve => {
                iframe.onload = resolve;
                setTimeout(resolve, 10000); // 10ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
            });
            
            try {
                const iframeWindow = iframe.contentWindow;
                const iframeDocument = iframe.contentDocument;
                
                // åŸºæœ¬è¦ç´ ã®å­˜åœ¨ç¢ºèª
                const canvas = iframeDocument.getElementById('mainCanvas');
                const controls = iframeDocument.getElementById('colorPalette');
                
                if (canvas && controls) {
                    checkResults.init = { status: 'pass', message: 'UIè¦ç´ æ­£å¸¸' };
                    log('âœ… åˆæœŸåŒ–: UIè¦ç´ ç¢ºèªå®Œäº†', 'pass');
                    
                    // PixelCanvasã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç¢ºèª
                    setTimeout(() => {
                        try {
                            const pixelCanvas = iframeWindow.pixelCanvas;
                            if (pixelCanvas) {
                                const stats = pixelCanvas.getStats();
                                if (stats.initialized) {
                                    checkResults.render = { status: 'pass', message: 'æç”»ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œ' };
                                    log('âœ… æç”»: ã‚·ã‚¹ãƒ†ãƒ æ­£å¸¸å‹•ä½œ', 'pass');
                                } else {
                                    checkResults.render = { status: 'warning', message: 'åˆæœŸåŒ–æœªå®Œäº†' };
                                    log('âš ï¸ æç”»: åˆæœŸåŒ–ãŒæœªå®Œäº†', 'warning');
                                }
                            } else {
                                checkResults.render = { status: 'fail', message: 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æœªç”Ÿæˆ' };
                                log('âŒ æç”»: PixelCanvasã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æœªç”Ÿæˆ', 'fail');
                            }
                        } catch (error) {
                            checkResults.render = { status: 'fail', message: 'ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼' };
                            log(`âŒ æç”»ç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'fail');
                        }
                        updateDisplay();
                    }, 3000);
                    
                } else {
                    checkResults.init = { status: 'fail', message: 'UIè¦ç´ ä¸è¶³' };
                    log('âŒ åˆæœŸåŒ–: å¿…è¦ãªUIè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'fail');
                }
                
            } catch (error) {
                checkResults.init = { status: 'fail', message: 'iframe ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯' };
                log(`âŒ æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'fail');
            }
            
            updateDisplay();
        }

        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç¢ºèª
        async function checkDatabase() {
            log('ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šç¢ºèª...', 'info');
            
            try {
                const response = await fetch('https://lgvjdefkyeuvquzckkvb.supabase.co/rest/v1/pixels?select=count&limit=1', {
                    headers: {
                        'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY',
                        'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY'
                    }
                });
                
                if (response.ok) {
                    checkResults.data = { status: 'pass', message: 'DBæ¥ç¶šæ­£å¸¸' };
                    log('âœ… ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: æ¥ç¶šæ­£å¸¸', 'pass');
                } else {
                    checkResults.data = { status: 'fail', message: `DBæ¥ç¶šå¤±æ•— ${response.status}` };
                    log(`âŒ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: æ¥ç¶šå¤±æ•— ${response.status}`, 'fail');
                }
                
            } catch (error) {
                checkResults.data = { status: 'fail', message: 'DBæ¥ç¶šã‚¨ãƒ©ãƒ¼' };
                log(`âŒ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'fail');
            }
            
            updateDisplay();
        }

        // æ€§èƒ½æ¸¬å®š
        async function measurePerformance() {
            log('âš¡ æ€§èƒ½æ¸¬å®šé–‹å§‹...', 'info');
            
            const startTime = performance.now();
            
            try {
                // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚é–“æ¸¬å®š
                const response = await fetch('https://nikomori0320.github.io/pixcel_canvas/');
                const endTime = performance.now();
                const loadTime = endTime - startTime;
                
                if (loadTime < 3000) {
                    checkResults.performance = { status: 'pass', message: `èª­ã¿è¾¼ã¿ ${loadTime.toFixed(0)}ms` };
                    log(`âœ… æ€§èƒ½: èª­ã¿è¾¼ã¿æ™‚é–“ ${loadTime.toFixed(0)}ms (è‰¯å¥½)`, 'pass');
                } else if (loadTime < 5000) {
                    checkResults.performance = { status: 'warning', message: `èª­ã¿è¾¼ã¿ ${loadTime.toFixed(0)}ms` };
                    log(`âš ï¸ æ€§èƒ½: èª­ã¿è¾¼ã¿æ™‚é–“ ${loadTime.toFixed(0)}ms (æ™®é€š)`, 'warning');
                } else {
                    checkResults.performance = { status: 'fail', message: `èª­ã¿è¾¼ã¿ ${loadTime.toFixed(0)}ms` };
                    log(`âŒ æ€§èƒ½: èª­ã¿è¾¼ã¿æ™‚é–“ ${loadTime.toFixed(0)}ms (é…ã„)`, 'fail');
                }
                
            } catch (error) {
                checkResults.performance = { status: 'fail', message: 'æ¸¬å®šå¤±æ•—' };
                log(`âŒ æ€§èƒ½æ¸¬å®šã‚¨ãƒ©ãƒ¼: ${error.message}`, 'fail');
            }
            
            updateDisplay();
        }

        // ä¿®æ­£ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        function generateFixReport() {
            log('ğŸ”§ ä¿®æ­£ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆä¸­...', 'info');
            
            checkResults.fixes = [];
            
            // å„çµæœã‹ã‚‰ä¿®æ­£æ¨å¥¨é …ç›®ã‚’æŠ½å‡º
            if (checkResults.deploy.status === 'fail') {
                checkResults.fixes.push('ãƒ‡ãƒ—ãƒ­ã‚¤ã®å†å®Ÿè¡ŒãŒå¿…è¦');
            }
            
            if (checkResults.init.status === 'fail') {
                checkResults.fixes.push('ã‚¢ãƒ—ãƒªåˆæœŸåŒ–å‡¦ç†ã®è¦‹ç›´ã—');
            }
            
            if (checkResults.render.status === 'fail') {
                checkResults.fixes.push('æç”»ã‚·ã‚¹ãƒ†ãƒ ã®ä¿®æ­£');
            }
            
            if (checkResults.data.status === 'fail') {
                checkResults.fixes.push('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã®ç¢ºèª');
            }
            
            if (checkResults.performance.status === 'fail') {
                checkResults.fixes.push('æ€§èƒ½æœ€é©åŒ–ã®å®Ÿæ–½');
            }
            
            log(`ğŸ“‹ ä¿®æ­£ãƒ¬ãƒãƒ¼ãƒˆ: ${checkResults.fixes.length}ä»¶ã®æ¨å¥¨äº‹é …`, 'info');
            checkResults.fixes.forEach((fix, index) => {
                log(`  ${index + 1}. ${fix}`, 'warning');
            });
            
            updateDisplay();
        }

        // å®Œå…¨ç¢ºèªå®Ÿè¡Œ
        async function startFullCheck() {
            log('ğŸš€ å®Œå…¨ç¢ºèªé–‹å§‹...', 'info');
            
            clearResults();
            
            await checkDeployStatus();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testAppFunctionality();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await checkDatabase();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await measurePerformance();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            generateFixReport();
            
            log('âœ… å®Œå…¨ç¢ºèªå®Œäº†', 'pass');
        }

        // ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆã‚¢ãƒ—ãƒªã‚’é–‹ã
        function openDeployedApp() {
            window.open('https://nikomori0320.github.io/pixcel_canvas/', '_blank');
            log('ğŸ“± ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆã‚¢ãƒ—ãƒªã‚’æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ãã¾ã—ãŸ', 'info');
        }

        // åˆæœŸåŒ–
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('ğŸ”„ ãƒ‡ãƒ—ãƒ­ã‚¤ç‰ˆç¢ºèªã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†', 'info');
                updateDisplay();
            }, 1000);
        });

    </script>
</body>
</html>