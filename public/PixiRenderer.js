// PixiJS + LOD „Å´„Çà„ÇãÈ´òÊÄßËÉΩ„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Ç®„É≥„Ç∏„É≥
import { CONFIG, Utils } from './Config.js';
import { LODGenerator } from './LODGenerator.js';

export class PixiRenderer {
    constructor(pixelCanvas) {
        this.pixelCanvas = pixelCanvas;
        this.app = null;
        this.viewport = null;
        this.tileLayer = null;
        this.container = document.getElementById('canvasContainer');
        
        // LODÁÆ°ÁêÜ
        this.currentLOD = 0;
        this.lodCache = new Map(); // LOD„É¨„Éô„É´ -> Map<sectorKey, texture>
        this.textureCache = new Map();
        
        // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®≠ÂÆö
        this.maxTextures = 500;
        this.lodThresholds = [2.0, 0.5, 0.125]; // scale thresholds for LOD 0,1,2,3
        
        // Áä∂ÊÖãÁÆ°ÁêÜ
        this.isInitialized = false;
        this.lastScale = 1.0;
        this.lastViewport = { x: 0, y: 0, width: 800, height: 600 };
        
        // LODÁîüÊàê„Ç∑„Çπ„ÉÜ„É†
        this.lodGenerator = new LODGenerator(pixelCanvas);
        this.lodGenerationPromise = null;
        
        // „Éó„É≠„Ç∞„É¨„ÉÉ„Ç∑„ÉñË™≠„ÅøËæº„Åø
        this.loadingQueue = new Map();
        this.preloadRadius = 1; // Âë®Ëæ∫„Çª„ÇØ„Çø„ÉºÂÖàË™≠„ÅøÁØÑÂõ≤
        
        this.initialize();
    }
    
    async initialize() {
        try {
            // Ë©≥Á¥∞„Å™„É©„Ç§„Éñ„É©„É™„ÉÅ„Çß„ÉÉ„ÇØ
            console.log('üîç Checking PixiJS libraries...');
            console.log('PIXI available:', !!window.PIXI);
            console.log('PIXI.tilemap available:', !!(window.PIXI && window.PIXI.tilemap));
            console.log('PIXI.Viewport available:', !!window.PIXI.Viewport);
            
            if (!window.PIXI) {
                console.warn('‚ö†Ô∏è PixiJS not loaded, falling back to Canvas renderer');
                return false;
            }
            
            // üö® CRITICAL FIX: Don't require tilemap - use basic PIXI functionality
            console.log('üîß Using basic PixiJS without tilemap dependency');
            
            console.log('üöÄ Initializing PixiJS renderer...');
            console.log('PixiJS version:', window.PIXI.VERSION || 'unknown');
            
            // PixiJSË®≠ÂÆö
            if (window.PIXI.settings) {
                window.PIXI.settings.SCALE_MODE = window.PIXI.SCALE_MODES.NEAREST; // „Éî„ÇØ„Çª„É´„Ç¢„Éº„ÉàÁî®
                window.PIXI.settings.ROUND_PIXELS = true;
            }
            
            // ContainerÂ≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ
            if (!this.container) {
                throw new Error('Canvas container not found');
            }
            
            const containerWidth = this.container.clientWidth || 800;
            const containerHeight = this.container.clientHeight || 600;
            
            console.log(`üìê Container size: ${containerWidth}x${containerHeight}`);
            
            // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥‰ΩúÊàê
            this.app = new window.PIXI.Application({
                width: containerWidth,
                height: containerHeight,
                backgroundColor: 0x404040,
                antialias: false,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            
            console.log('‚úÖ PIXI Application created successfully');
            
            // CanvasË¶ÅÁ¥†„ÇíËøΩÂä†
            this.app.view.id = 'pixiCanvas';
            this.app.view.style.position = 'absolute';
            this.app.view.style.top = '0';
            this.app.view.style.left = '0';
            this.app.view.style.width = '100%';
            this.app.view.style.height = '100%';
            this.app.view.style.zIndex = '10'; // üîß CRITICAL: Higher z-index to ensure visibility
            this.app.view.style.pointerEvents = 'auto';
            this.app.view.style.display = 'block';
            
            console.log('üîß Adding PixiJS canvas to container', {
                containerSize: { width: containerWidth, height: containerHeight },
                canvasStyle: this.app.view.style.cssText
            });
            
            this.container.appendChild(this.app.view);
            
            // üîß EMERGENCY: Force canvas visibility
            setTimeout(() => {
                this.app.view.style.opacity = '1';
                this.app.view.style.visibility = 'visible';
                console.log('üîß PixiJS canvas forced visible');
            }, 100);
            
            // üîß CRITICAL FIX: Setup simplified rendering without dependencies
            this.setupSimpleContainer();
            
            // TileMap„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
            this.trySetupTileMap();
            
            // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É©
            this.setupResize();
            
            this.isInitialized = true;
            console.log('‚úÖ PixiJS renderer initialized successfully');
            
            // üß™ CRITICAL TEST: Add test sprite to verify rendering works
            this.addTestSprite();
            
            // ÂàùÂõûLODÁîüÊàê„ÇíÈñãÂßãÔºàÈùûÂêåÊúüÔºâ
            this.startInitialLODGeneration();
            
            // RealtimeÊ©üËÉΩ„ÇíË®≠ÂÆöÔºàÂ∞ë„ÅóÈÅÖ„Çâ„Åõ„Å¶Ôºâ
            setTimeout(() => {
                this.setupRealtimeSubscription();
            }, 1000);
            
            return true;
            
        } catch (error) {
            console.error('‚ùå PixiJS initialization failed:', error);
            return false;
        }
    }
    
    setupSimpleContainer() {
        try {
            console.log('üîß Setting up simple container without Viewport dependency...');
            
            // üö® CRITICAL FIX: Use basic PIXI Container instead of Viewport
            this.viewport = new PIXI.Container();
            
            // Set initial position to show sector (0,0) where most pixels are
            this.viewport.x = 0;
            this.viewport.y = 0;
            this.viewport.scale.set(2); // Reasonable zoom to see pixels
            
            this.app.stage.addChild(this.viewport);
            
            console.log('‚úÖ Simple container created successfully');
            
            // Try to setup Viewport if available (optional enhancement)
            this.trySetupViewport();
            
        } catch (error) {
            console.error('‚ùå Simple container setup failed:', error);
            throw error;
        }
    }
    
    trySetupViewport() {
        try {
            console.log('üîß Attempting to setup Viewport (optional)...');
            
            const ViewportClass = window.PIXI.Viewport || window.Viewport;
            if (!ViewportClass) {
                console.log('‚ö†Ô∏è Viewport not available, using simple container');
                return;
            }
            
            // Replace simple container with viewport
            this.app.stage.removeChild(this.viewport);
            
            this.viewport = new ViewportClass({
                screenWidth: this.container.clientWidth || 800,
                screenHeight: this.container.clientHeight || 600,
                worldWidth: 100000,
                worldHeight: 100000,
                events: this.app.renderer.events // üîß FIXED: Use events instead of interaction
            });
            
            // „Ç´„É°„É©Êìç‰ΩúË®≠ÂÆö
            this.viewport
                .drag()
                .pinch()
                .wheel({ smooth: 3 })
                .decelerate()
                .clampZoom({ minScale: 0.05, maxScale: 16 });
            
            // Set initial viewport to show sector (0,0)
            this.viewport.moveCenter(CONFIG.GRID_SIZE / 2, CONFIG.GRID_SIZE / 2);
            this.viewport.setZoom(2);
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            this.viewport.on('moved', () => this.onViewportChange());
            this.viewport.on('zoomed', () => this.onViewportChange());
            this.viewport.on('zoomed-end', () => this.checkLODLevel());
            
            this.app.stage.addChild(this.viewport);
            
            console.log('‚úÖ Viewport upgrade successful');
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Viewport setup failed, using simple container:', error);
        }
    }
    
    addTestSprite() {
        try {
            console.log('üß™ Adding test sprite to verify PixiJS rendering...');
            
            // Create a simple colored square as test
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0xff0000); // Red color
            graphics.drawRect(0, 0, 50, 50);
            graphics.endFill();
            
            // Position it in the center of screen
            graphics.x = 100;
            graphics.y = 100;
            
            this.viewport.addChild(graphics);
            
            // Also add a text label
            const text = new PIXI.Text('PixiJS Test', {
                fontFamily: 'Arial',
                fontSize: 16,
                fill: 0xffffff
            });
            text.x = 100;
            text.y = 160;
            
            this.viewport.addChild(text);
            
            console.log('‚úÖ Test sprite added successfully');
            
        } catch (error) {
            console.error('‚ùå Failed to add test sprite:', error);
        }
    }
    
    // üîß CRITICAL: Main render method called from main.js
    async render() {
        if (!this.isInitialized) {
            console.warn('‚ö†Ô∏è PixiJS renderer not initialized');
            return;
        }
        
        console.log('üé® PixiJS render called');
        
        // üîß CRITICAL FIX: Render actual pixels from storage
        this.renderFromPixelStorage();
        
        // Also load LOD data if available
        this.loadVisibleSectors();
    }
    
    // üö® CRITICAL: Create pixel textures directly from PixelStorage
    renderFromPixelStorage() {
        try {
            const pixelStorage = this.pixelCanvas.pixelStorage;
            if (!pixelStorage || pixelStorage.pixels.size === 0) {
                console.log('‚ö†Ô∏è No pixels in storage to render');
                return;
            }
            
            console.log(`üé® Rendering ${pixelStorage.pixels.size} pixels with PixiJS`);
            
            // Clear previous pixels (simple approach)
            this.viewport.children
                .filter(child => child.userData && child.userData.isPixel)
                .forEach(pixel => this.viewport.removeChild(pixel));
            
            let rendered = 0;
            const maxPixels = 1000; // Limit for performance
            
            for (const [key, color] of pixelStorage.pixels) {
                if (rendered >= maxPixels) break;
                
                const [sectorX, sectorY, localX, localY] = key.split(',').map(Number);
                
                // Convert to world coordinates
                const worldX = sectorX * CONFIG.GRID_SIZE + localX;
                const worldY = sectorY * CONFIG.GRID_SIZE + localY;
                
                // Create pixel sprite
                const graphics = new PIXI.Graphics();
                graphics.beginFill(parseInt(CONFIG.PALETTE[color].replace('#', '0x')));
                graphics.drawRect(0, 0, 1, 1); // 1x1 pixel
                graphics.endFill();
                
                graphics.x = worldX;
                graphics.y = worldY;
                graphics.userData = { isPixel: true };
                
                this.viewport.addChild(graphics);
                rendered++;
            }
            
            console.log(`‚úÖ Rendered ${rendered} pixels with PixiJS`);
            
        } catch (error) {
            console.error('‚ùå PixiJS pixel rendering failed:', error);
        }
    }
    
    trySetupTileMap() {
        try {
            console.log('üîß Attempting to setup TileMap (optional)...');
            
            if (!window.PIXI.tilemap) {
                console.log('‚ö†Ô∏è PIXI.tilemap not available, using sprite fallback');
                return;
            }
            
            // üîß FIXED: Use correct CompositeTilemap class from latest @pixi/tilemap
            this.tileLayer = new window.PIXI.tilemap.CompositeTilemap();
            this.viewport.addChild(this.tileLayer);
            
            console.log('‚úÖ TileMap created successfully');
            
        } catch (error) {
            console.error('‚ùå TileMap setup failed:', error);
            throw error;
        }
    }
    
    setupResize() {
        window.addEventListener('resize', () => {
            const width = this.container.clientWidth;
            const height = this.container.clientHeight;
            
            this.app.renderer.resize(width, height);
            if (this.viewport) {
                this.viewport.resize(width, height);
            }
        });
    }
    
    onViewportChange() {
        const scale = this.viewport.scale.x;
        const newLOD = this.calculateLOD(scale);
        
        // LODÂ§âÊõ¥ÊôÇ„ÅÆÂá¶ÁêÜ
        if (newLOD !== this.currentLOD) {
            console.log(`üîÑ LOD changed: ${this.currentLOD} ‚Üí ${newLOD} (scale: ${scale.toFixed(3)})`);
            this.currentLOD = newLOD;
            this.loadVisibleSectors();
        }
        
        // „Éì„É•„Éº„Éù„Éº„ÉàÂ§âÊõ¥ÊôÇ„ÅØÈ†ªÂ∫¶„ÇíÂà∂Èôê
        if (Math.abs(scale - this.lastScale) > 0.01) {
            this.lastScale = scale;
            this.throttledLoadSectors();
        }
    }
    
    calculateLOD(scale) {
        // „Çπ„Ç±„Éº„É´„Å´Âü∫„Å•„ÅÑ„Å¶LOD„É¨„Éô„É´„ÇíÊ±∫ÂÆö
        // È´ò„ÅÑ„Çπ„Ç±„Éº„É´Ôºà„Ç∫„Éº„É†„Ç§„É≥Ôºâ= ‰Ωé„ÅÑLOD„É¨„Éô„É´ÔºàÈ´òËß£ÂÉèÂ∫¶Ôºâ
        // ‰Ωé„ÅÑ„Çπ„Ç±„Éº„É´Ôºà„Ç∫„Éº„É†„Ç¢„Ç¶„ÉàÔºâ= È´ò„ÅÑLOD„É¨„Éô„É´Ôºà‰ΩéËß£ÂÉèÂ∫¶Ôºâ
        for (let i = 0; i < this.lodThresholds.length; i++) {
            if (scale >= this.lodThresholds[i]) {
                return i;
            }
        }
        return this.lodThresholds.length; // ÊúÄ‰ΩéLOD (ÊúÄ„ÇÇÁ≤ó„ÅÑËß£ÂÉèÂ∫¶)
    }
    
    checkLODLevel() {
        if (!this.viewport) return;
        
        const currentScale = this.viewport.scale.x;
        const newLOD = this.calculateLOD(currentScale);
        
        // „Éí„Çπ„ÉÜ„É™„Ç∑„ÇπÔºàÈ†ªÁπÅ„Å™Âàá„ÇäÊõø„Åà„ÇíÈò≤„ÅêÔºâ
        if (Math.abs(newLOD - this.currentLOD) >= 1) {
            console.log(`üîÑ LOD Level changed: ${this.currentLOD} ‚Üí ${newLOD} (scale: ${currentScale.toFixed(3)})`);
            this.currentLOD = newLOD;
            
            // LOD„ÅåÂ§â„Çè„Å£„ÅüÂ†¥Âêà„ÄÅË°®Á§∫„ÇíÊõ¥Êñ∞
            this.loadVisibleSectors();
        }
    }
    
    throttledLoadSectors = Utils.throttle(() => {
        this.loadVisibleSectors();
    }, 100);
    
    async loadVisibleSectors() {
        if (!this.isInitialized) return;
        
        const bounds = this.calculateVisibleBounds();
        const lodLevel = this.currentLOD;
        
        
        // Ë°®Á§∫ÁØÑÂõ≤„ÅÆ„Çª„ÇØ„Çø„Éº„ÇíÂèñÂæó
        for (let sectorX = bounds.minSectorX; sectorX <= bounds.maxSectorX; sectorX++) {
            for (let sectorY = bounds.minSectorY; sectorY <= bounds.maxSectorY; sectorY++) {
                await this.loadSectorLOD(sectorX, sectorY, lodLevel);
            }
        }
        
        // Âè§„ÅÑ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        this.cleanupTextures();
    }
    
    async loadSectorLOD(sectorX, sectorY, lodLevel) {
        const sectorKey = `${sectorX},${sectorY}`;
        const cacheKey = `${sectorKey}:${lodLevel}`;
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
        if (this.textureCache.has(cacheKey)) {
            this.renderSectorTexture(sectorX, sectorY, lodLevel);
            return;
        }
        
        try {
            // Supabase„Åã„ÇâLOD„Éá„Éº„Çø„ÇíÂèñÂæó
            const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/sector_lod?sector_x=eq.${sectorX}&sector_y=eq.${sectorY}&lod_level=eq.${lodLevel}&select=*`, {
                headers: {
                    'apikey': CONFIG.SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`
                }
            });
            
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const lodData = await response.json();
            
            if (lodData.length > 0) {
                // LOD„Éá„Éº„Çø„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà
                const texture = await this.createTextureFromLOD(lodData[0]);
                this.textureCache.set(cacheKey, texture);
                this.renderSectorTexture(sectorX, sectorY, lodLevel);
            } else {
                // üîß CRITICAL FIX: LOD„Éá„Éº„Çø„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØPixelStorage„Åã„ÇâÁõ¥Êé•„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÁîüÊàê
                console.log(`üîß No LOD data for sector (${sectorX},${sectorY}), generating from PixelStorage`);
                const texture = await this.createTextureFromPixelStorage(sectorX, sectorY, lodLevel);
                if (texture) {
                    this.textureCache.set(cacheKey, texture);
                    this.renderSectorTexture(sectorX, sectorY, lodLevel);
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Failed to load sector LOD ${cacheKey}:`, error);
            
            // üîß CRITICAL FALLBACK: Try PixelStorage even on error
            try {
                console.log(`üîß Falling back to PixelStorage for sector (${sectorX},${sectorY})`);
                const texture = await this.createTextureFromPixelStorage(sectorX, sectorY, lodLevel);
                if (texture) {
                    this.textureCache.set(cacheKey, texture);
                    this.renderSectorTexture(sectorX, sectorY, lodLevel);
                }
            } catch (fallbackError) {
                console.error(`‚ùå PixelStorage fallback also failed:`, fallbackError);
            }
        }
    }
    
    async createTextureFromLOD(lodData) {
        // RLE„Éá„Éº„Çø„Åã„ÇâImageBitmap„ÇíÁîüÊàê
        const width = lodData.width;
        const height = lodData.height;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // RLE„Éá„Ç≥„Éº„ÉâÔºàÁ∞°Áï•ÁâàÔºâ
        if (lodData.rle_data) {
            // ÂÆüÈöõ„ÅÆRLE„Éá„Ç≥„Éº„ÉâÂá¶ÁêÜ„Çí„Åì„Åì„Å´ÂÆüË£Ö
            this.decodeRLEToCanvas(lodData.rle_data, ctx, width, height);
        }
        
        // PIXI„ÉÜ„ÇØ„Çπ„ÉÅ„É£‰ΩúÊàê
        const baseTexture = PIXI.BaseTexture.from(canvas);
        baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
        return new PIXI.Texture(baseTexture);
    }
    
    // üîß CRITICAL NEW: Create texture directly from PixelStorage
    async createTextureFromPixelStorage(sectorX, sectorY, lodLevel) {
        const pixelStorage = this.pixelCanvas.pixelStorage;
        const scale = Math.pow(2, lodLevel); // 1, 2, 4, 8
        const textureSize = Math.floor(CONFIG.GRID_SIZE / scale);
        
        console.log(`üé® Creating texture for sector (${sectorX},${sectorY}) LOD ${lodLevel}, size: ${textureSize}x${textureSize}`);
        
        // Create canvas for texture
        const canvas = document.createElement('canvas');
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext('2d');
        
        // Clear with transparent background
        ctx.clearRect(0, 0, textureSize, textureSize);
        
        let pixelsRendered = 0;
        
        // Render pixels from storage to canvas
        for (let localY = 0; localY < CONFIG.GRID_SIZE; localY += scale) {
            for (let localX = 0; localX < CONFIG.GRID_SIZE; localX += scale) {
                // Get pixel color from storage
                const color = pixelStorage.getPixel(sectorX, sectorY, localX, localY);
                
                if (color !== undefined) {
                    // Convert to canvas coordinates
                    const canvasX = Math.floor(localX / scale);
                    const canvasY = Math.floor(localY / scale);
                    
                    // Get color from palette
                    const hexColor = CONFIG.PALETTE[color] || '#000000';
                    ctx.fillStyle = hexColor;
                    
                    // Fill pixel (with scaling for LOD)
                    const pixelSize = Math.max(1, 1);
                    ctx.fillRect(canvasX, canvasY, pixelSize, pixelSize);
                    pixelsRendered++;
                }
            }
        }
        
        console.log(`üé® Rendered ${pixelsRendered} pixels to texture for sector (${sectorX},${sectorY})`);
        
        // Only create texture if there are pixels to show
        if (pixelsRendered > 0) {
            const baseTexture = PIXI.BaseTexture.from(canvas);
            baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
            return new PIXI.Texture(baseTexture);
        }
        
        return null;
    }
    
    decodeRLEToCanvas(rleData, ctx, width, height) {
        if (!rleData) {
            // „Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÁ©∫„ÅÆ„Ç≠„É£„É≥„Éê„Çπ
            ctx.clearRect(0, 0, width, height);
            return;
        }
        
        try {
            // Base64„Éá„Ç≥„Éº„Éâ
            const binaryString = atob(rleData);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            
            // RLE„Éá„Ç≥„Éº„Éâ
            const pixelArray = new Uint8Array(width * height);
            let pos = 0;
            
            for (let i = 0; i < bytes.length; i += 2) {
                if (i + 1 >= bytes.length) break;
                
                const color = bytes[i];
                const count = bytes[i + 1];
                
                for (let j = 0; j < count && pos < pixelArray.length; j++) {
                    pixelArray[pos++] = color;
                }
            }
            
            // ImageData„Å´Â§âÊèõ
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            for (let i = 0; i < pixelArray.length; i++) {
                const colorIndex = pixelArray[i];
                const color = CONFIG.PALETTE[colorIndex] || '#000000';
                
                // Ëâ≤ÊñáÂ≠óÂàó„ÇíRGB„Å´Â§âÊèõ
                const rgb = this.hexToRgb(color);
                const pixelIndex = i * 4;
                
                data[pixelIndex] = rgb.r;     // R
                data[pixelIndex + 1] = rgb.g; // G
                data[pixelIndex + 2] = rgb.b; // B
                data[pixelIndex + 3] = colorIndex === 0 ? 0 : 255; // A (ÈÄèÊòé or ‰∏çÈÄèÊòé)
            }
            
            ctx.putImageData(imageData, 0, 0);
            
        } catch (error) {
            console.error('‚ùå RLE decode failed:', error);
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Êó¢Â≠ò„Éî„ÇØ„Çª„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÁõ¥Êé•ÊèèÁîª
            this.renderSectorFromStorage(ctx, width, height);
        }
    }
    
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }
    
    renderSectorFromStorage(ctx, width, height) {
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Éî„ÇØ„Çª„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÁõ¥Êé•ÊèèÁîª
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;
        
        // „Å®„Çä„ÅÇ„Åà„Åö„ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                const intensity = ((x + y) % 32) * 8;
                data[index] = intensity;     // R
                data[index + 1] = intensity; // G
                data[index + 2] = intensity; // B
                data[index + 3] = 255;       // A
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    
    renderSectorTexture(sectorX, sectorY, lodLevel) {
        const cacheKey = `${sectorX},${sectorY}:${lodLevel}`;
        const texture = this.textureCache.get(cacheKey);
        
        if (!texture) {
            console.warn(`‚ö†Ô∏è No texture found for ${cacheKey}`);
            return;
        }
        
        // üîß FIXED: PixiJS world coordinates (no pixel size scaling needed here)
        const worldX = sectorX * CONFIG.GRID_SIZE;
        const worldY = sectorY * CONFIG.GRID_SIZE;
        const size = CONFIG.GRID_SIZE;
        
        console.log(`üé® Rendering texture for sector (${sectorX}, ${sectorY}) at world (${worldX}, ${worldY}) size ${size}`);
        
        // üö® CRITICAL FIX: Use Sprite instead of problematic TileMap
        try {
            const sprite = new PIXI.Sprite(texture);
            sprite.x = worldX;
            sprite.y = worldY;
            sprite.width = size;
            sprite.height = size;
            
            // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ - Âêå„Åò‰ΩçÁΩÆ„ÅÆ„Çπ„Éó„É©„Ç§„Éà„ÇíÂâäÈô§
            const existingSprites = this.viewport.children.filter(child => 
                child instanceof PIXI.Sprite && 
                child.x === worldX && 
                child.y === worldY
            );
            existingSprites.forEach(sprite => this.viewport.removeChild(sprite));
            
            this.viewport.addChild(sprite);
            console.log(`‚úÖ Added sprite for sector (${sectorX}, ${sectorY}) at (${worldX}, ${worldY})`);
            
        } catch (error) {
            console.error(`‚ùå Failed to add sprite:`, error);
        }
    }
    
    async generateSectorLOD(sectorX, sectorY, lodLevel) {
        console.log(`üîß Generating LOD ${lodLevel} for sector (${sectorX}, ${sectorY})`);
        
        // Êó¢Â≠ò„ÅÆ„Éî„ÇØ„Çª„É´„Éá„Éº„Çø„Åã„ÇâÁ∏ÆÂ∞èÁâà„ÇíÁîüÊàê
        const pixelStorage = this.pixelCanvas.pixelStorage;
        const scale = Math.pow(2, lodLevel); // 1, 2, 4, 8
        const lodSize = Math.floor(CONFIG.GRID_SIZE / scale);
        
        // Á∞°Áï•ÁâàLODÁîüÊàê
        const lodData = {
            sector_x: sectorX,
            sector_y: sectorY,
            lod_level: lodLevel,
            width: lodSize,
            height: lodSize,
            rle_data: null,
            pixel_count: 0,
            avg_color: 0
        };
        
        // Supabase„Å´‰øùÂ≠ò
        try {
            await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/sector_lod`, {
                method: 'POST',
                headers: {
                    'apikey': CONFIG.SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(lodData)
            });
            
            console.log(`‚úÖ Generated LOD ${lodLevel} for sector (${sectorX}, ${sectorY})`);
        } catch (error) {
            console.error(`‚ùå Failed to save LOD:`, error);
        }
    }
    
    calculateVisibleBounds() {
        if (!this.viewport) {
            // Fallback if viewport not ready
            return {
                minSectorX: -1, maxSectorX: 1,
                minSectorY: -1, maxSectorY: 1
            };
        }
        
        const bounds = this.viewport.getVisibleBounds();
        const gridSize = CONFIG.GRID_SIZE; // PixiJS uses world coordinates directly
        
        console.log(`üîß PIXI Viewport bounds:`, {
            x: bounds.x, y: bounds.y, 
            width: bounds.width, height: bounds.height,
            gridSize: gridSize
        });
        
        const result = {
            minSectorX: Math.floor(bounds.x / gridSize) - 1,
            maxSectorX: Math.ceil((bounds.x + bounds.width) / gridSize) + 1,
            minSectorY: Math.floor(bounds.y / gridSize) - 1,
            maxSectorY: Math.ceil((bounds.y + bounds.height) / gridSize) + 1
        };
        
        console.log(`üîß PIXI Calculated sector bounds:`, result);
        return result;
    }
    
    cleanupTextures() {
        if (this.textureCache.size <= this.maxTextures) return;
        
        // Âè§„ÅÑ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂâäÈô§
        const entries = Array.from(this.textureCache.entries());
        const toDelete = entries.slice(0, entries.length - this.maxTextures + 100);
        
        for (const [key, texture] of toDelete) {
            texture.destroy(true);
            this.textureCache.delete(key);
        }
        
        console.log(`üßπ Cleaned up ${toDelete.length} textures`);
    }
    
    render() {
        if (!this.isInitialized) {
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Êó¢Â≠ò„É¨„É≥„ÉÄ„É©„Éº„Çí‰ΩøÁî®
            this.pixelCanvas.renderEngine.render();
            return;
        }
        
        console.log(`üîß PIXI Render called, pixels available: ${this.pixelCanvas.pixelStorage.pixels.size}`);
        
        // PixiJS„ÅØËá™Âãï„É¨„É≥„ÉÄ„É™„É≥„Ç∞
        // ÂøÖË¶Å„Å´Âøú„Åò„Å¶tileLayer„ÇíÊõ¥Êñ∞
        this.tileLayer.clear();
        
        // üîß EMERGENCY FIX: Force PixelStorage rendering instead of LOD database queries
        this.renderFromPixelStorage();
    }
    
    renderFromPixelStorage() {
        const pixelStorage = this.pixelCanvas.pixelStorage;
        console.log(`üé® PIXI rendering from PixelStorage: ${pixelStorage.pixels.size} pixels`);
        
        // Get visible bounds in sector coordinates
        const bounds = this.calculateVisibleBounds();
        console.log(`üîß Visible bounds:`, bounds);
        
        // Render sectors that have pixels
        const sectorsToRender = new Set();
        
        // Check which sectors have pixels
        for (const [key, color] of pixelStorage.pixels) {
            const [sectorX, sectorY] = key.split(',').map(Number);
            const sectorKey = `${sectorX},${sectorY}`;
            sectorsToRender.add(sectorKey);
        }
        
        console.log(`üé® Sectors with pixels: ${sectorsToRender.size}`, Array.from(sectorsToRender));
        
        // Render each sector that has pixels
        for (const sectorKey of sectorsToRender) {
            const [sectorX, sectorY] = sectorKey.split(',').map(Number);
            
            // Force create texture from PixelStorage
            this.forceRenderSector(sectorX, sectorY);
        }
    }
    
    async forceRenderSector(sectorX, sectorY) {
        console.log(`üîß Force rendering sector (${sectorX}, ${sectorY})`);
        
        const lodLevel = this.currentLOD;
        const cacheKey = `${sectorX},${sectorY}:${lodLevel}`;
        
        try {
            // Create texture directly from PixelStorage
            const texture = await this.createTextureFromPixelStorage(sectorX, sectorY, lodLevel);
            if (texture) {
                this.textureCache.set(cacheKey, texture);
                this.renderSectorTexture(sectorX, sectorY, lodLevel);
                console.log(`‚úÖ Successfully rendered sector (${sectorX}, ${sectorY})`);
            } else {
                console.warn(`‚ö†Ô∏è No texture created for sector (${sectorX}, ${sectorY})`);
            }
        } catch (error) {
            console.error(`‚ùå Failed to force render sector (${sectorX}, ${sectorY}):`, error);
        }
    }
    
    // üöÄ Supabase RealtimeÁµ±Âêà
    setupRealtimeSubscription() {
        if (!this.pixelCanvas.networkManager.supabaseClient) {
            console.warn('‚ö†Ô∏è Supabase client not available for realtime');
            return;
        }
        
        const supabase = this.pixelCanvas.networkManager.supabaseClient;
        
        // „Éî„ÇØ„Çª„É´Êõ¥Êñ∞„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ
        this.pixelSubscription = supabase
            .channel('pixel-updates')
            .on(
                'postgres_changes',
                {
                    event: '*',
                    schema: 'public',
                    table: 'pixels'
                },
                (payload) => this.handlePixelRealtimeUpdate(payload)
            )
            .subscribe();
            
        // LODÊõ¥Êñ∞„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ
        this.lodSubscription = supabase
            .channel('lod-updates')
            .on(
                'postgres_changes',
                {
                    event: '*',
                    schema: 'public',
                    table: 'sector_lod'
                },
                (payload) => this.handleLODRealtimeUpdate(payload)
            )
            .subscribe();
            
        console.log('‚úÖ Realtime subscriptions established');
    }
    
    handlePixelRealtimeUpdate(payload) {
        const { eventType, new: newRecord, old: oldRecord } = payload;
        
        switch (eventType) {
            case 'INSERT':
                this.handlePixelInsert(newRecord);
                break;
            case 'UPDATE':
                this.handlePixelUpdate(newRecord, oldRecord);
                break;
            case 'DELETE':
                this.handlePixelDelete(oldRecord);
                break;
        }
    }
    
    async handlePixelInsert(pixel) {
        const { sector_x, sector_y, local_x, local_y, color } = pixel;
        
        console.log(`üîÑ Realtime pixel insert: (${sector_x}, ${sector_y}) at (${local_x}, ${local_y}) color ${color}`);
        
        // „É≠„Éº„Ç´„É´„Éî„ÇØ„Çª„É´„Çπ„Éà„É¨„Éº„Ç∏„ÇíÊõ¥Êñ∞
        this.pixelCanvas.pixelStorage.setPixel(sector_x, sector_y, local_x, local_y, color);
        
        // ÂΩ±Èüø„ÇíÂèó„Åë„ÇãLOD„É¨„Éô„É´„ÇíÊõ¥Êñ∞
        if (this.lodGenerator) {
            await this.lodGenerator.updateLODForPixelChange(sector_x, sector_y, local_x, local_y, color);
        }
        
        // ÁèæÂú®Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã„Çª„ÇØ„Çø„Éº„Å™„ÇâÂç≥Â∫ß„Å´Êõ¥Êñ∞
        const sectorKey = `${sector_x},${sector_y}`;
        if (this.isVisibleSector(sector_x, sector_y)) {
            await this.refreshSectorTexture(sector_x, sector_y);
        }
    }
    
    async handlePixelUpdate(newPixel, oldPixel) {
        // „Éî„ÇØ„Çª„É´Êõ¥Êñ∞„ÅØINSERT„Å®Âêå„ÅòÂá¶ÁêÜ
        await this.handlePixelInsert(newPixel);
    }
    
    async handlePixelDelete(pixel) {
        const { sector_x, sector_y, local_x, local_y } = pixel;
        
        console.log(`üîÑ Realtime pixel delete: (${sector_x}, ${sector_y}) at (${local_x}, ${local_y})`);
        
        // „É≠„Éº„Ç´„É´„Éî„ÇØ„Çª„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÂâäÈô§
        this.pixelCanvas.pixelStorage.deletePixel(sector_x, sector_y, local_x, local_y);
        
        // LOD„ÇíÊõ¥Êñ∞
        if (this.lodGenerator) {
            await this.lodGenerator.updateLODForPixelChange(sector_x, sector_y, local_x, local_y, 0);
        }
        
        // Ë°®Á§∫Êõ¥Êñ∞
        if (this.isVisibleSector(sector_x, sector_y)) {
            await this.refreshSectorTexture(sector_x, sector_y);
        }
    }
    
    handleLODRealtimeUpdate(payload) {
        const { eventType, new: newRecord } = payload;
        
        if (eventType === 'INSERT' || eventType === 'UPDATE') {
            const { sector_x, sector_y, lod_level } = newRecord;
            const cacheKey = `${sector_x},${sector_y}:${lod_level}`;
            
            console.log(`üîÑ Realtime LOD update: (${sector_x}, ${sector_y}) level ${lod_level}`);
            
            // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢ÔºàÊ¨°Âõû„Ç¢„ÇØ„Çª„ÇπÊôÇ„Å´ÂÜçÁîüÊàêÔºâ
            this.textureCache.delete(cacheKey);
            
            // ÁèæÂú®„ÅÆLOD„É¨„Éô„É´„Å®‰∏ÄËá¥„Åó„ÄÅË°®Á§∫ÁØÑÂõ≤ÂÜÖ„Å™„ÇâÂç≥Â∫ß„Å´ÂÜç„É≠„Éº„Éâ
            if (lod_level === this.currentLOD && this.isVisibleSector(sector_x, sector_y)) {
                this.loadSectorLOD(sector_x, sector_y, lod_level);
            }
        }
    }
    
    isVisibleSector(sectorX, sectorY) {
        const bounds = this.calculateVisibleBounds();
        return sectorX >= bounds.minSectorX && 
               sectorX <= bounds.maxSectorX && 
               sectorY >= bounds.minSectorY && 
               sectorY <= bounds.maxSectorY;
    }
    
    async refreshSectorTexture(sectorX, sectorY) {
        // ÂÖ®LOD„É¨„Éô„É´„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
        for (let level = 0; level <= 3; level++) {
            const cacheKey = `${sectorX},${sectorY}:${level}`;
            const texture = this.textureCache.get(cacheKey);
            if (texture) {
                texture.destroy(true);
                this.textureCache.delete(cacheKey);
            }
        }
        
        // ÁèæÂú®„ÅÆLOD„É¨„Éô„É´„ÅßÂÜç„É≠„Éº„Éâ
        await this.loadSectorLOD(sectorX, sectorY, this.currentLOD);
    }
    
    // LODÁîüÊàêÈñ¢ÈÄ£„É°„ÇΩ„ÉÉ„Éâ
    async startInitialLODGeneration() {
        if (this.lodGenerationPromise) return;
        
        console.log('üèóÔ∏è Starting initial LOD generation...');
        
        this.lodGenerationPromise = this.lodGenerator.generateAllLODs()
            .then(() => {
                console.log('‚úÖ Initial LOD generation completed');
                this.loadVisibleSectors(); // LODÁîüÊàêÂæå„Å´ÂÜçÊèèÁîª
            })
            .catch(error => {
                console.error('‚ùå LOD generation failed:', error);
            })
            .finally(() => {
                this.lodGenerationPromise = null;
            });
    }
    
    // „Éó„É≠„Ç∞„É¨„ÉÉ„Ç∑„ÉñË™≠„ÅøËæº„Åø: ‰ΩéLOD‚ÜíÈ´òLOD„ÅÆÈ†Ü„ÅßË™≠„ÅøËæº„Åø
    async loadSectorProgressive(sectorX, sectorY) {
        const currentLOD = this.currentLOD;
        
        // ‰ΩéLOD„Åã„ÇâÈ´òLOD„Åæ„ÅßÊÆµÈöéÁöÑ„Å´Ë™≠„ÅøËæº„Åø
        for (let lod = Math.min(3, currentLOD + 1); lod >= Math.max(0, currentLOD - 1); lod--) {
            await this.loadSectorLOD(sectorX, sectorY, lod);
            
            // È´òÂÑ™ÂÖàÂ∫¶LOD„ÅåË¶ã„Å§„Åã„Å£„Åü„ÇâÂç≥Â∫ß„Å´Ë°®Á§∫
            const cacheKey = `${sectorX},${sectorY}:${lod}`;
            if (this.textureCache.has(cacheKey)) {
                this.renderSectorTexture(sectorX, sectorY, lod);
                
                // ÁèæÂú®„ÅÆLOD„Å´Âêà„Å£„ÅüËß£ÂÉèÂ∫¶„Å™„ÇâÂÆå‰∫Ü
                if (lod === currentLOD) break;
            }
        }
    }
    
    // Âë®Ëæ∫„Çª„ÇØ„Çø„Éº„ÅÆÂÖàË™≠„Åø
    async preloadAdjacentSectors(centerX, centerY, radius = 1) {
        const preloadPromises = [];
        
        for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
                if (dx === 0 && dy === 0) continue; // ‰∏≠Â§Æ„ÅØÊó¢„Å´Ë™≠„ÅøËæº„ÅøÊ∏à„Åø
                
                const sectorX = centerX + dx;
                const sectorY = centerY + dy;
                
                preloadPromises.push(
                    this.loadSectorLOD(sectorX, sectorY, this.currentLOD)
                        .catch(error => {
                            // „Ç®„É©„Éº„ÅØÈùô„Åã„Å´ÁÑ°Ë¶ñÔºàÂÖàË™≠„Åø„Å™„ÅÆ„ÅßÔºâ
                            console.debug(`Preload failed for (${sectorX}, ${sectorY}):`, error);
                        })
                );
            }
        }
        
        // ÂÖàË™≠„Åø„ÅØ‰ΩéÂÑ™ÂÖàÂ∫¶„Å™„ÅÆ„Åß„ÄÅ‰∏ÄÈÉ®Â§±Êïó„Åó„Å¶„ÇÇÁ∂öË°å
        await Promise.allSettled(preloadPromises);
    }
    
    // „Éî„ÇØ„Çª„É´Êõ¥Êñ∞ÊôÇ„ÅÆLODÂêåÊúüÊõ¥Êñ∞
    async updateLODForPixelChange(sectorX, sectorY, localX, localY, color) {
        // „É™„Ç¢„É´„Çø„Ç§„É†Êõ¥Êñ∞
        await this.lodGenerator.updateLODForPixelChange(sectorX, sectorY, localX, localY, color);
        
        // ÂΩ±Èüø„ÇíÂèó„Åë„Çã„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Çí„Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÂâäÈô§
        for (let lod = 0; lod <= 3; lod++) {
            const cacheKey = `${sectorX},${sectorY}:${lod}`;
            const texture = this.textureCache.get(cacheKey);
            if (texture) {
                texture.destroy(true);
                this.textureCache.delete(cacheKey);
            }
        }
        
        // ÁèæÂú®Ë°®Á§∫‰∏≠„ÅÆLOD„ÇíÂÜçË™≠„ÅøËæº„Åø
        await this.loadSectorLOD(sectorX, sectorY, this.currentLOD);
    }
    
    // „Éí„Çπ„ÉÜ„É™„Ç∑„Çπ‰ªò„ÅçLODÂàá„ÇäÊõø„Åà
    calculateLODWithHysteresis(scale) {
        const newLOD = this.calculateLOD(scale);
        
        // „Éí„Çπ„ÉÜ„É™„Ç∑„Çπ: ÈñæÂÄ§‰ªòËøë„Åß„ÅÆÈ†ªÁπÅ„Å™Âàá„ÇäÊõø„Åà„ÇíÈò≤„Åê
        if (Math.abs(newLOD - this.currentLOD) === 1) {
            const threshold = this.lodThresholds[Math.min(newLOD, this.currentLOD)];
            const hysteresis = threshold * 0.1; // 10%„ÅÆ„Éê„ÉÉ„Éï„Ç°
            
            if (newLOD > this.currentLOD) {
                // „Çà„ÇäÈ´òË©≥Á¥∞„Å∏„ÅÆÂàá„ÇäÊõø„Åà: „Çà„ÇäÂé≥Ê†º„Å™Êù°‰ª∂
                return scale >= threshold + hysteresis ? newLOD : this.currentLOD;
            } else {
                // „Çà„Çä‰ΩéË©≥Á¥∞„Å∏„ÅÆÂàá„ÇäÊõø„Åà: „Çà„ÇäÁ∑©„ÅÑÊù°‰ª∂
                return scale <= threshold - hysteresis ? newLOD : this.currentLOD;
            }
        }
        
        return newLOD;
    }
    
    destroy() {
        if (this.app) {
            this.app.destroy(true);
        }
        
        for (const texture of this.textureCache.values()) {
            texture.destroy(true);
        }
        
        this.textureCache.clear();
        this.lodCache.clear();
        this.loadingQueue.clear();
        
        // Realtime subscription„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        if (this.pixelSubscription) {
            this.pixelSubscription.unsubscribe();
        }
        if (this.lodSubscription) {
            this.lodSubscription.unsubscribe();
        }
        
        if (this.lodGenerator) {
            this.lodGenerator.destroy();
        }
    }
    
    // „Éá„Éê„ÉÉ„Ç∞Áî®
    getPerformanceStats() {
        return {
            renderer: 'PixiJS',
            isInitialized: this.isInitialized,
            currentLOD: this.currentLOD,
            textureCount: this.textureCache.size,
            scale: this.viewport?.scale.x || 1,
            webgl: this.app?.renderer.type === PIXI.RENDERER_TYPE.WEBGL
        };
    }
}