<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Performance Test - Progressive Loading</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: monospace; padding: 20px; }
        .test { margin: 10px 0; padding: 10px; border: 1px solid #333; }
        .pass { border-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .fail { border-color: #f44336; background: rgba(244, 67, 54, 0.1); }
        .running { border-color: #2196F3; background: rgba(33, 150, 243, 0.1); }
        button { padding: 10px; margin: 5px; background: #333; color: white; border: 1px solid #666; cursor: pointer; }
        .log { max-height: 300px; overflow-y: auto; background: #222; padding: 10px; margin: 10px 0; border: 1px solid #444; font-size: 12px; }
        .progress { width: 100%; height: 20px; background: #333; margin: 10px 0; }
        .progress-bar { height: 100%; background: #4CAF50; transition: width 0.3s; }
    </style>
</head>
<body>
    <h1>üìä Progressive Loading Performance Test</h1>
    
    <div class="test" id="test1">
        <h3>Test 1: Progressive Loading (Recommended Fix)</h3>
        <div id="test1-result">Ready to test...</div>
        <div class="progress"><div id="progress1" class="progress-bar" style="width: 0%"></div></div>
    </div>
    
    <div class="test" id="test2">
        <h3>Test 2: Batch Processing Performance</h3>
        <div id="test2-result">Ready to test...</div>
        <div class="progress"><div id="progress2" class="progress-bar" style="width: 0%"></div></div>
    </div>
    
    <div class="test" id="test3">
        <h3>Test 3: Memory-Efficient Rendering</h3>
        <div id="test3-result">Ready to test...</div>
    </div>
    
    <div>
        <button onclick="testProgressiveLoading()">Test Progressive Loading</button>
        <button onclick="testBatchProcessing()">Test Batch Processing</button>
        <button onclick="testMemoryEfficient()">Test Memory Efficient</button>
        <button onclick="simulateFreeze()">Simulate Freeze (Current Bug)</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>
    
    <div class="log" id="testLog">Performance test results will appear here...</div>
    
    <script>
        const CONFIG = {
            SUPABASE_URL: 'https://lgvjdefkyeuvquzckkvb.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxndmpkZWZreWV1dnF1emNra3ZiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3MjMxNzEsImV4cCI6MjA2NTI5OTE3MX0.AqXyT6m78-O7X-ulzYdfBsLLMVsRoelpOUvPp9PCqiY',
            PIXEL_SIZE: 4,
            GRID_SIZE: 256,
            COLORS: [
                '#000000', '#FFFFFF', '#FF0000', '#00FF00',
                '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                '#800000', '#008000', '#000080', '#808000',
                '#800080', '#008080', '#C0C0C0', '#808080'
            ]
        };
        
        function log(message) {
            const testLog = document.getElementById('testLog');
            const timestamp = new Date().toLocaleTimeString();
            testLog.innerHTML += `[${timestamp}] ${message}<br>`;
            testLog.scrollTop = testLog.scrollHeight;
        }
        
        function setTestStatus(testId, status, message) {
            const test = document.getElementById(testId);
            const result = document.getElementById(testId + '-result');
            test.className = 'test ' + status;
            result.innerHTML = message;
        }
        
        function updateProgress(progressId, percent) {
            document.getElementById(progressId).style.width = percent + '%';
        }
        
        // Mock pixel storage for testing
        class MockPixelStorage {
            constructor() {
                this.pixels = new Map();
                this.renderQueue = [];
            }
            
            addPixel(sectorX, sectorY, localX, localY, color) {
                const key = `${sectorX},${sectorY},${localX},${localY}`;
                this.pixels.set(key, color);
            }
            
            clear() {
                this.pixels.clear();
                this.renderQueue = [];
            }
        }
        
        // Test 1: Progressive Loading (Recommended Solution)
        window.testProgressiveLoading = async function() {
            setTestStatus('test1', 'running', '‚è≥ Testing progressive loading...');
            log('üîÑ Starting progressive loading test...');
            
            const storage = new MockPixelStorage();
            const batchSize = 1000;
            const totalPixels = 10000; // Test with 10k pixels
            let loadedPixels = 0;
            
            try {
                for (let offset = 0; offset < totalPixels; offset += batchSize) {
                    const startTime = performance.now();
                    
                    // Simulate loading batch
                    const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=sector_x,sector_y,local_x,local_y,color&limit=${batchSize}&offset=${offset}`, {
                        headers: {
                            'apikey': CONFIG.SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (response.ok) {
                        const pixels = await response.json();
                        
                        // Process in smaller sub-batches to prevent freezing
                        for (let i = 0; i < pixels.length; i += 100) {
                            const subBatch = pixels.slice(i, i + 100);
                            
                            // Add to storage
                            for (const pixel of subBatch) {
                                storage.addPixel(pixel.sector_x, pixel.sector_y, pixel.local_x, pixel.local_y, pixel.color);
                                loadedPixels++;
                            }
                            
                            // Yield control to browser every 100 pixels
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                        
                        const loadTime = performance.now() - startTime;
                        const progress = Math.min(100, (offset + pixels.length) / totalPixels * 100);
                        
                        updateProgress('progress1', progress);
                        log(`Loaded batch ${Math.floor(offset/batchSize) + 1}: ${pixels.length} pixels in ${loadTime.toFixed(0)}ms (total: ${loadedPixels})`);
                        
                        // Break if we get fewer pixels than expected
                        if (pixels.length < batchSize) break;
                    }
                }
                
                setTestStatus('test1', 'pass', `‚úÖ PASS: Progressive loading completed<br>Loaded ${loadedPixels} pixels<br>No browser freeze detected`);
                log(`‚úÖ Progressive loading test completed: ${loadedPixels} pixels loaded without freezing`);
                
            } catch (error) {
                setTestStatus('test1', 'fail', `‚ùå FAIL: ${error.message}`);
                log(`‚ùå Progressive loading failed: ${error.message}`);
            }
        };
        
        // Test 2: Batch Processing Performance
        window.testBatchProcessing = async function() {
            setTestStatus('test2', 'running', '‚è≥ Testing batch processing...');
            log('üîÑ Starting batch processing test...');
            
            const storage = new MockPixelStorage();
            const batchSizes = [100, 500, 1000, 2000, 5000];
            const results = [];
            
            try {
                for (const batchSize of batchSizes) {
                    const startTime = performance.now();
                    
                    // Load batch
                    const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=*&limit=${batchSize}`, {
                        headers: {
                            'apikey': CONFIG.SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (response.ok) {
                        const pixels = await response.json();
                        
                        // Process batch with yielding
                        for (let i = 0; i < pixels.length; i += 50) {
                            const subBatch = pixels.slice(i, i + 50);
                            for (const pixel of subBatch) {
                                storage.addPixel(pixel.sector_x, pixel.sector_y, pixel.local_x, pixel.local_y, pixel.color);
                            }
                            if (i + 50 < pixels.length) {
                                await new Promise(resolve => setTimeout(resolve, 1));
                            }
                        }
                        
                        const loadTime = performance.now() - startTime;
                        results.push({ batchSize, loadTime: loadTime.toFixed(0), pixels: pixels.length });
                        
                        const progress = (batchSizes.indexOf(batchSize) + 1) / batchSizes.length * 100;
                        updateProgress('progress2', progress);
                        
                        log(`Batch size ${batchSize}: ${pixels.length} pixels in ${loadTime.toFixed(0)}ms`);
                    }
                }
                
                const bestBatch = results.reduce((best, current) => 
                    current.loadTime < best.loadTime ? current : best
                );
                
                setTestStatus('test2', 'pass', 
                    `‚úÖ PASS: Batch processing completed<br>` +
                    `Best performance: ${bestBatch.batchSize} pixels/batch (${bestBatch.loadTime}ms)<br>` +
                    `Recommended: 1000 pixel batches with 50-pixel sub-batches`
                );
                
            } catch (error) {
                setTestStatus('test2', 'fail', `‚ùå FAIL: ${error.message}`);
                log(`‚ùå Batch processing failed: ${error.message}`);
            }
        };
        
        // Test 3: Memory-Efficient Rendering
        window.testMemoryEfficient = async function() {
            setTestStatus('test3', 'running', '‚è≥ Testing memory-efficient rendering...');
            log('üîÑ Starting memory efficiency test...');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');
                
                // Test rendering with different pixel counts
                const testCounts = [1000, 5000, 10000, 20000];
                const results = [];
                
                for (const count of testCounts) {
                    const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const startTime = performance.now();
                    
                    // Clear canvas
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Render test pixels with LOD (Level of Detail)
                    const skipFactor = Math.max(1, Math.floor(count / 5000)); // Adaptive LOD
                    let rendered = 0;
                    
                    for (let i = 0; i < count; i += skipFactor) {
                        const x = (i % 200) * 2;
                        const y = Math.floor(i / 200) * 2;
                        ctx.fillStyle = CONFIG.COLORS[i % 16];
                        ctx.fillRect(x, y, 2, 2);
                        rendered++;
                        
                        // Yield every 100 renders
                        if (rendered % 100 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                    
                    const renderTime = performance.now() - startTime;
                    const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const memoryDelta = endMemory - startMemory;
                    
                    results.push({ 
                        count, 
                        rendered, 
                        renderTime: renderTime.toFixed(0), 
                        memoryDelta: Math.round(memoryDelta / 1024 / 1024) 
                    });
                    
                    log(`Rendered ${rendered}/${count} pixels (LOD: ${skipFactor}) in ${renderTime.toFixed(0)}ms, memory: ${Math.round(memoryDelta / 1024 / 1024)}MB`);
                }
                
                setTestStatus('test3', 'pass', 
                    `‚úÖ PASS: Memory-efficient rendering<br>` +
                    `Results: ${results.map(r => `${r.count}‚Üí${r.rendered} (${r.renderTime}ms)`).join(', ')}<br>` +
                    `LOD system prevents freeze with large datasets`
                );
                
            } catch (error) {
                setTestStatus('test3', 'fail', `‚ùå FAIL: ${error.message}`);
                log(`‚ùå Memory test failed: ${error.message}`);
            }
        };
        
        // Simulate the current freeze issue
        window.simulateFreeze = async function() {
            log('‚ö†Ô∏è SIMULATING FREEZE: Loading 10,000 pixels synchronously (like current bug)...');
            const startTime = performance.now();
            
            try {
                // This simulates the problematic behavior
                const response = await fetch(`${CONFIG.SUPABASE_URL}/rest/v1/pixels?select=*&limit=10000`, {
                    headers: {
                        'apikey': CONFIG.SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`
                    }
                });
                
                const pixels = await response.json();
                log(`Loaded ${pixels.length} pixels...`);
                
                // Process all at once (causes freeze)
                const storage = new MockPixelStorage();
                for (const pixel of pixels) {
                    storage.addPixel(pixel.sector_x, pixel.sector_y, pixel.local_x, pixel.local_y, pixel.color);
                }
                
                const freezeTime = performance.now() - startTime;
                log(`‚ö†Ô∏è Synchronous processing took ${freezeTime.toFixed(0)}ms - this causes the freeze!`);
                
            } catch (error) {
                log(`‚ùå Freeze simulation failed: ${error.message}`);
            }
        };
        
        window.clearLog = function() {
            document.getElementById('testLog').innerHTML = '';
            updateProgress('progress1', 0);
            updateProgress('progress2', 0);
        };
        
        // Auto-display summary
        document.addEventListener('DOMContentLoaded', () => {
            log('üìä Performance Test Suite Ready');
            log('Problem: 65,543 pixels loaded synchronously causes browser freeze');
            log('Solution: Progressive loading with batch processing and yielding');
            log('Run tests to see the difference in performance');
        });
    </script>
</body>
</html>